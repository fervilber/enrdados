n=100 # numencuestados
# creamos 3 series una para cada pregunta de la encuesta
# Pregunta A: Si/NO con 20% de SI
A<-ifelse(runif(n)>0.8,"SI","NO") # 1=si
A<-as.factor(A) # lo convertimos a factor
# creamos la tabla con la primera col
tabla_encuesta<-data.frame(A)
# Pregunta B: 3 respuestas posibles 3 prob
# usando sample para asignar prob a cada respuesta posible
B<-sample(c("a","b","c"),size=100,replace = T,prob=c(0.6,0.3,0.1))
#    # creamos una funcion para las respuestas:
#    # OJO: Ver opción simplificada en el siguiente script
#    encuesta2<-function(x,pa=0.9,pb=0.6){
#        # 3 posibles respuestas con p1= 0,6 p2=0,3  p3=0,1
#        # deben sumar 1
#        if (x>pa) return("c")
#        else if (x>pb ) return("b")
#        else return("a")
#        }
#    # generamos 100
#    v <- runif(n)
#    tabla_encuesta$B<-as.factor(sapply(v,encuesta2))
# Pregunta C: valoracion de 0 a 10. entero
C<-round(rnorm(n,6,2))
C<-ifelse(C>10,10,C) # comprobamos que no sea > de 10
# Añadimos la ultima respuesta
tabla_encuesta$C<-C
head(tabla_encuesta,10)
str(tabla_encuesta)
#summary(tabla_encuesta)
barplot(table(tabla_encuesta$A))
barplot(table(tabla_encuesta$B))
barplot(table(tabla_encuesta$C))
p<-ggplot(data=tabla_encuesta, aes( y=A)) +
geom_bar(stat="identity")
p
table(tabla_encuesta$A)
names(tabla_encuesta)
# Pregunta B: 3 respuestas posibles 3 prob
# usando sample para asignar prob a cada respuesta posible
B<-sample(c("a","b","c"),size=100,replace = T,prob=c(0.6,0.3,0.1))
tabla_encuesta$B<-B
head(tabla_encuesta,10)
rownames(tabla_encuesta)
t_encuesta<-melt(tabla_encuesta ,  id.vars = rownames(tabla_encuesta), variable.name = 'series')
t_encuesta
t_encuesta<-melt(tabla_encuesta ,  id.vars = rownames(tabla_encuesta), variable.name = 'series')
tabla_encuesta$id<-rownames(tabla_encuesta)
head(tabla_encuesta,10)
t_encuesta<-melt(tabla_encuesta ,  id.vars = 'id', variable.name = 'series')
t_encuesta
n=100 # numencuestados
# creamos 3 series una para cada pregunta de la encuesta
# Pregunta A: Si/NO con 20% de SI
A<-ifelse(runif(n)>0.8,"SI","NO") # 1=si
A<-as.factor(A) # lo convertimos a factor
# creamos la tabla con la primera col
tabla_encuesta<-data.frame(A)
# Pregunta B: 3 respuestas posibles 3 prob
# usando sample para asignar prob a cada respuesta posible
B<-sample(c("a","b","c"),size=100,replace = T,prob=c(0.6,0.3,0.1))
tabla_encuesta$B<-as.factor(B)
# Pregunta C: valoracion de 0 a 10. entero
C<-round(rnorm(n,6,2))
C<-ifelse(C>10,10,C) # comprobamos que no sea > de 10
# Añadimos la ultima respuesta
tabla_encuesta$C<-as.factor(C)
tabla_encuesta$id<-rownames(tabla_encuesta)
head(tabla_encuesta,10)
t_encuesta<-melt(tabla_encuesta ,  id.vars = 'id', variable.name = 'series')
t_encuesta
p<-ggplot(data=t_encuesta, aes(x=id y=series)) +
geom_bar(stat="identity")
p
p<-ggplot(data=t_encuesta, aes(x=id, y=series)) +
geom_bar(stat="identity")
p
p<-ggplot(data=t_encuesta, aes(x=value, fill=series)) +
geom_bar(stat="identity")
p
t_encuesta
p<-ggplot(data=t_encuesta, aes(x=value, y=series,fill=series)) +
geom_bar(stat="identity")
p
p<-ggplot(data=t_encuesta, aes(x=value, y=series,fill=series)) +
geom_bar(stat="identity")+
facet_wrap(vars(series))+
theme_cowplot(8)
p
head(tabla_encuesta,10)
ggplot(data=tabla_encuesta, aes(x=A, y=id)) +
geom_bar(stat="identity")+
theme_cowplot(8)
ggplot(data=tabla_encuesta, aes(x=A, y=id)) +
geom_col(stat="identity")+
theme_cowplot(8)
ggplot(data=tabla_encuesta, aes(x=A, y=id)) +
geom_col()+
theme_cowplot(8)
ggplot(data=tabla_encuesta, aes(x=A, y=id)) +
geom_col()+
theme_cowplot(8)
ggplot(data=tabla_encuesta, aes(x=A, y=id)) +
geom_col()
ggplot(data=tabla_encuesta, aes(x=A)) +
geom_col()
ggplot(data=tabla_encuesta, aes(x=A)) +
geom_bar()
ggplot(data=tabla_encuesta, aes(x=A)) +
geom_bar()+
theme_cowplot(8)
ggplot(data=tabla_encuesta, aes(x=A)) +
geom_bar(col=1:2)+
theme_cowplot(8)
ggplot(data=tabla_encuesta, aes(x=A)) +
geom_bar(aes(fill=A))+
theme_cowplot(8)
p2<-ggplot(data=tabla_encuesta, aes(x=B)) +
geom_bar(aes(fill=B))+
theme_cowplot(8)
p3<-ggplot(data=tabla_encuesta, aes(x=C)) +
geom_bar(aes(fill=C))+
theme_cowplot(8)
p2
p1+ p2 /p3
p1<-ggplot(data=tabla_encuesta, aes(x=A)) +
geom_bar(aes(fill=A))+
theme_cowplot(8)
p2<-ggplot(data=tabla_encuesta, aes(x=B)) +
geom_bar(aes(fill=B))+
theme_cowplot(8)
p3<-ggplot(data=tabla_encuesta, aes(x=C)) +
geom_bar(aes(fill=C))+
theme_cowplot(8)
p1+ p2 /p3
(p1 + p2) /p3
g_encuesta<-(p1 + p2) /p3
g_encuesta+ plot_annotation(tag_levels = 'A')
g_encuesta+ plot_annotation(tag_levels = 'A',tag_prefix = 'Pregunta. ')
p3<-ggplot(data=tabla_encuesta, aes(x=C)) +
geom_bar(aes(fill=C),show.legend = NA)+
theme_cowplot(8)
g_encuesta<-(p1 + p2) /p3
g_encuesta+ plot_annotation(tag_levels = 'A',tag_prefix = 'Pregunta. ')
p1<-ggplot(data=tabla_encuesta, aes(x=A)) +
geom_bar(aes(fill=A),show.legend = FALSE)+
theme_cowplot(8)
p2<-ggplot(data=tabla_encuesta, aes(x=B)) +
geom_bar(aes(fill=B),show.legend = FALSE)+
theme_cowplot(8)
p3<-ggplot(data=tabla_encuesta, aes(x=C)) +
geom_bar(aes(fill=C),show.legend = FALSE)+
theme_cowplot(8)
g_encuesta<-(p1 + p2) /p3
g_encuesta+ plot_annotation(tag_levels = 'A',tag_prefix = 'Pregunta. ')
blogdown:::serve_site()
blogdown:::insert_image_addin()
blogdown:::new_post_addin()
knitr::opts_chunk$set(error=FALSE,echo = TRUE, warning = FALSE, message = FALSE)
#/post/2021-05-30-unir-graficas-en-una-imagen/images/pach1.png
# /post/2021-06-14-generacion-aleatoria/images/aleatorio.png'
library(tidyverse)
library(tidyverse)
library(stringr)
library(pdftools)
# leemos las paginas del pdf una a una y separamos por filas
fich_pdf<-pdf_text("Listado de notas Prep. 2021.pdf") %>%
str_split("\n")
# leemos las paginas del pdf una a una y separamos por filas
fich_pdf<-pdf_text("Listado de notas Prep. 2021.pdf") %>%
str_split("\n")
str(fich_pdf)
# numero de paginas leidas del documento
length(fich_pdf)
# numero de filas leidas por pag
lengths(fich_pdf)
head(fich_pdf)
head(fich_pdf[[1]])
head(fich_pdf[[1]],10)
# me quedo solo con líneas de datos de la tabla
#Ojo primero las de abajo para no cambiar la numeracion
fich_pdf[[1]] <- fich_pdf[[1]][-41:-46]
fich_pdf[[1]] <- fich_pdf[[1]][-1:-8]
# ahora la pagina 2
fich_pdf[[2]] <- fich_pdf[[2]][-13:-34]
fich_pdf[[2]] <- fich_pdf[[2]][-1:-4]
fich_pdf
head(fich_pdf)
#juntamos todo en un data frame
# quitamos espacios sobrantes con str_squish
aux<-unlist(fich_pdf) %>% str_squish()
#quito primera linea
aux<-aux[-1]
aux
#juntamos todo en un data frame
# quitamos espacios sobrantes con str_squish
aux<-unlist(fich_pdf) %>% str_squish()
aux
head(aux)
num<-aux %>% str_extract("[[:digit:]]+(?=\\.)")
num
aux
#quito primera linea
aux<-aux[-1]
aux %>% str_extract("[[:digit:]]+(?=\\.)")
aux
# almacenamos en el vector num los números de línea
num<-aux %>% str_extract("[[:digit:]]+(?=\\.)")
# sacamos los apellidos:
#     está precedido por . y espacio y finalizan con coma , mas un espacio
apellido<-aux %>% str_extract("(?<=\\.\\s)[[:print:]]+(?=\\,\\s)")
# quito las variables ya leidas del vector
aux1<-str_squish(substring(aux, first = 4))
aux1<-str_replace_all( aux1, apellido,"" )
# quito la coma y espacio
aux1<-substring(aux1, first = 3)
aux1
apellido
aux1
aux1<-aux1 %>% strsplit(split= " ")
nota<-map_chr(aux1,~.x[[1]])
nota
aux1
head(aux1)
walk(aux1,print)
head(aux1)
# quito las variables ya leidas del vector
aux1<-str_squish(substring(aux, first = 4))
aux1<-str_replace_all( aux1, apellido,"" )
# quito la coma y espacio
aux1<-substring(aux1, first = 3)
# Extraigo el nombre:
# el nombre comienza con la coma y espacio y finaliza con espacio y digito y coma seguidos
#nom<-aux %>% str_extract("(?<=\\,\\s)[[:print:]]+(?=[[:digit:]]\\,)")
# el nombre finaliza con espacio+digito+coma
nom<-aux1 %>% str_extract("[[:print:]]+(?=\\s[[:digit:]]\\,)")
aux1<-str_replace_all( aux1, nom,"" ) # lo quito de aux1 el nombre
aux1<-str_squish(aux1)
head(aux1)
walk(aux1,print)
head(aux1)
aux1
aux2<-aux1 %>% strsplit(split= " ")
aux2
unlist(aux2)
walk(aux2,print)
walk(aux2,print)[1:6]
walk(aux2,head)
walk(aux2,print)
walk(aux2,print,3)
walk(aux2[1:6],print)
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::insert_image_addin()
blogdown:::insert_image_addin()
install.packages(c("blogdown", "bookdown"))
install.packages(c("blogdown", "bookdown"))
blogdown:::new_post_addin()
blogdown:::insert_image_addin()
knitr::opts_chunk$set(error=FALSE,echo = TRUE, warning = FALSE, message = FALSE)
#/post/2021-05-30-unir-graficas-en-una-imagen/images/pach1.png
# '/post/2021-04-26-office-desde-r/images/pach2.png'
#funcion que pinta de manera iterativa las ramas
ramas<-function(pini, w, l, ang, lmin_rama=10,color="white") {
# pini= punto inicio linea rama c(x,y)
# w= ancho de la rama
# l= largo de la rama
# ang= angulo de la rama
# lmin_rama= limite min de long de rama recomendado h/50
x1 = pini[1] - l * cos(ang);
y1 = pini[2] + l * sin(ang);
pfin = c(x1, y1)
# color de las ramas que va aumentando el alfa en las hojas
col01<-adjustcolor(color,alpha.f = 1-lmin_rama/l)
# pinta la linea con los datos dados
lines(c(pini[1],pfin[1]),c(pini[2],pfin[2]),lwd=w,col=col01)
# Calcula la siguiente bifurcación:
dif<- pi/2 #- (pi / 16)
angle1<-ang+ runif(1,0,dif)/2
angle2<-ang- runif(1,0,dif)/2
# calcula aleatoriamente un nuevo grueso y largo de las ramas bifurcadas
n_ancho = runif(1,w * 0.6, w * 0.8);
n_largo = runif(1,l * 0.7, l * 0.9);
# Controla el crecimiento recursivo hasta el limite min de rama
if (n_largo < lmin_rama) {
# sale del loop, fin de función
}else { # pinta las nuevas ramas de la bifurcación
ramas(pfin, n_ancho, n_largo, angle1,lmin_rama,col=col01);
if(runif(1)>0.3){ # un 30% de las veces no se bifurcará
ramas(pfin, n_ancho, n_largo, angle2,lmin_rama,col=col01)
}
}
}
# función que pinta el arbol
parbol <- function(h = 100,ramificacion=50,base=h/2,colort="white", sobreescribe=NULL) {
# h = altura media del arbol
# base= posición de x0 del tronco en principio h/2
# ramificaciones = a mayor-->más ramas y más complejo
if (is.null(sobreescribe)) {
#pinta el lienzo en blanco
plot(1:h,type="n",
xlim = c(0,h),
ylim = c(0,h),
xlab = " ",ylab=" ")
}
# calculo de variables:
largo <- runif(1,h/10,h/5) # altura tronco
ancho <- sample(6:25,1)  # ancho tronco
angulo_rama = pi / 2 # angulo de rama inicial 90
# puntos xy de la linea del tronco principal
x1= base;   y1 = 0
x2 = base ; y2 = largo
# pintamos el tronco en las coordenadas x1,x2  y1,y2
# ajuste de color del arbol
col01<-adjustcolor(colort,alpha.f = 1)
abline(h=0,lwd=ancho/2, col=col01) #linea de suelo
# tronco base; lend indica la forma de extremo de linea (par)
lines(c(x1,x2),c(y1,y2),lwd=ancho,col=col01, lend=1)
angle1<-angulo_rama+ rnorm(1)*pi/16 # angulo de la siguiente parte del tronco
# Llama a la función de creación de las ramas a partir del punto
# final del tronco
ramas(c(x2,y2), ancho, largo, angle1,h/ramificacion,color=colort)
}
parbol(h,150,color="black")
parbol(100,150,color="black")
# Creo un arbol de altura 100
parbol(,150,color="black")
parbol(120,150,base=20,color="black",sobreescribe=1)
parbol(120,150,color="black")
parbol(120,150,base=20,color="black",sobreescribe=1)
par(bg = 'black')
parbol(120,150,color="white")
parbol(120,150,base=20,color="white",sobreescribe=1)
# Creo un arbol de altura 100
parbol(120,150,color="black")
blogdown:::serve_site()
####################################
######## Función que pinta el arbol
parbol <- function(h = 100,ramificacion=50,base=h/2,colort="white", sobreescribe=NULL) {
# h = altura media del arbol
# base= posición de x0 del tronco en principio h/2
# ramificaciones = a mayor-->más ramas y más complejo
if (is.null(sobreescribe)) {
#pinta el lienzo en blanco
plot(1:h,type="n",
xlim = c(0,h),
ylim = c(0,h),
xlab = " ",ylab=" ")
}
# calculo de variables:
largo <- runif(1,h/10,h/5) # altura tronco
ancho <- sample(6:25,1)  # ancho tronco
angulo_rama = pi / 2 # angulo de rama inicial 90
# puntos xy de la linea del tronco principal
x1= base;   y1 = 0
x2 = base ; y2 = largo
# pintamos el tronco en las coordenadas x1,x2  y1,y2
# ajuste de color del arbol
col01<-adjustcolor(colort,alpha.f = 1)
abline(h=0,lwd=ancho/2, col=col01) #linea de suelo
# tronco base; lend indica la forma de extremo de linea (par)
lines(c(x1,x2),c(y1,y2),lwd=ancho,col=col01, lend=1)
angle1<-angulo_rama+ rnorm(1)*pi/16 # angulo de la siguiente parte del tronco
# Llama a la función de creación de las ramas a partir del punto
# final del tronco
ramas(c(x2,y2), ancho, largo, angle1,h/ramificacion,color=colort)
}
####################################
######## Funcion que pinta las ramas
ramas<-function(pini, w, l, ang, lmin_rama=10,color="white") {
# pini= punto inicio linea rama c(x,y)
# w= ancho de la rama
# l= largo de la rama
# ang= angulo de la rama
# lmin_rama= limite min de long de rama recomendado h/50
x1 = pini[1] - l * cos(ang);
y1 = pini[2] + l * sin(ang);
pfin = c(x1, y1)
# color de las ramas que va aumentando el alfa en las hojas
col01<-adjustcolor(color,alpha.f = 1-lmin_rama/l)
# pinta la linea con los datos dados
lines(c(pini[1],pfin[1]),c(pini[2],pfin[2]),lwd=w,col=col01)
# Calcula la siguiente bifurcación:
dif<- pi/2 #- (pi / 16)
angle1<-ang+ runif(1,0,dif)/2
angle2<-ang- runif(1,0,dif)/2
# calcula aleatoriamente un nuevo grueso y largo de las ramas bifurcadas
n_ancho = runif(1,w * 0.6, w * 0.8);
n_largo = runif(1,l * 0.7, l * 0.9);
# Controla el crecimiento recursivo hasta el limite min de rama
if (n_largo < lmin_rama) {
# sale del loop, fin de función
}else { # pinta las nuevas ramas de la bifurcación
ramas(pfin, n_ancho, n_largo, angle1,lmin_rama,col=col01);
if(runif(1)>0.3){ # un 30% de las veces no se bifurcará
ramas(pfin, n_ancho, n_largo, angle2,lmin_rama,col=col01)
}
}
}
blogdown:::serve_site()
blogdown:::serve_site()
knitr::opts_chunk$set(error=FALSE,echo = TRUE, warning = FALSE, message = FALSE)
#![arbol generado con un algoritmo recursivo](images/ARBOL_DOBLE_RAMI01.png)
parbol(120,150,base=70,color="white")
parbol(120,150,base=20,color="darkred",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70,color="white")
parbol(90,150,base=20,color="darkred",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70,color="white")
parbol(90,150,base=20,color="red",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,100,base=20,color="grey",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,100,base=20,color="grey",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,100,base=20,color="grey",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,100,base=20,color="grey",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,100,base=20,color="white",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,100,base=20,color="white",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,200,base=20,color="white",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,200,base=20,color="white",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(120,200,base=20,color="white",sobreescribe=1)
parbol(120,150)
parbol(120,200,sobreescribe=1)
par(bg = 'black')
parbol(120,150)
parbol(120,200,sobreescribe=1)
par(bg = 'black')
parbol(120,150)
parbol(120,200,sobreescribe=1)
# Ejemplo de diagrama de flujo SANKEY
library(networkD3)      # cargamos librería
# Definimos los nodos de la red, que se numeran automáticamente de 0 a ..
nodes = data.frame("name" =
c("Fuente clara",  # Node 0
"Bombeo 1",      # Node 1
"Ayt. Villalocos",  # Node 2
"Ayt. Torrecilla",         # Nodo 3
"C.RR 1",        # Nodo 4
"C.RR 2",        # Nodo 5
"Embalse alto",  # Nodo 6
"Ayt. Puerto Plata", # Nodo 7
"Ayt. Jerjes",   # Nodo 8
"Fuente Negra"   # Nodo 9
))
# Definimos ahora los flujos en la forma siguiente:
# nodo origen, nodo final, cantidad de flujo
links = as.data.frame(matrix(c(
0, 1, 53, # desde, a, cuanto
0, 3, 5,
0, 4, 10,
1, 3, 5,
1, 8, 3,
1, 5, 7,
1, 4, 5,
1, 6, 32,
6,2,25,
6,7,7,
6,3,2,
9,3,40,
9,1,3),
byrow = TRUE, ncol = 3))
# nombramos las columnas con los nombres estándar de la librería networkD3
names(links) = c("source", "target", "value")
# Llamamos a la funcion de dibujo del diagrama
sankeyNetwork(Links = links, Nodes = nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
fontSize= 10, nodeWidth = 50,nodePadding = 10,
colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"
)
)
# Descargamos los datos
URL <- paste0('https://cdn.rawgit.com/christophergandrud/networkD3/',
'master/JSONdata/energy.json')
energy <- jsonlite::fromJSON(URL)
#knitr::kable(head(energy),"html")
str(energy)
# Pintamos la grafica simple sin colorear flujos
sankeyNetwork(Links = energy$links, Nodes = energy$nodes, Source = 'source',
Target = 'target', Value = 'value', NodeID = 'name',
units = 'TWh', fontSize = 12, nodeWidth = 30)
# flujo coloreados
energy$links$energy_type <- sub(' .*', '',
energy$nodes[energy$links$source + 1, 'name'])
# los colores del flujo los definimos segun los valores de energy$links$energy_type
knitr::kable(head(energy$links$energy_type))
# pintamos la grafica con flujo coloreados
sankeyNetwork(Links = energy$links, Nodes = energy$nodes, Source = 'source',
Target = 'target', Value = 'value', NodeID = 'name',
LinkGroup = 'energy_type', NodeGroup = NULL)
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
