plot(st_cast(st_buffer(is2,300),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,500),"MULTILINESTRING"), col = 'blue', add = TRUE)
text(st_coordinates(is2_c), labels = nom_I, pos = 4)
plot(st_cast(st_buffer(is2,400),"MULTILINESTRING"), col = 'darkblue', add = TRUE)
plot(st_cast(st_buffer(is2,100),"MULTILINESTRING"), col = 'blue', add = TRUE)
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
par(family = ‘avenir’)
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
par(family = 'avenir')
plot(st_geometry(is2), col="burlywood4", border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber",bg = 'cyan')
plot(st_geometry(st_centroid(is2)),pch = 3, col = 'red', add = TRUE)
plot(st_cast(st_buffer(is2,100),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,300),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,400),"MULTILINESTRING"), col = 'darkblue', add = TRUE)
text(st_coordinates(is2_c), labels = nom_I, pos = 4)
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
quartzFonts(avenir = c(“Avenir Book”, “Avenir Black”, “Avenir Book Oblique”,
“Avenir Black Oblique”))
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
quartzFonts(avenir = c("Avenir Book", "Avenir Black", "Avenir Book Oblique" ,"Avenir Black Oblique"))
#library(ggspatial)
#library(rgeos) # gbuffer
# para usar otras caligrafias
library(extrafont)
install.packages("extrafont")
font_import() solo una vez  al instalar
#library(ggspatial)
#library(rgeos) # gbuffer
# para usar otras caligrafias
library(extrafont)
font_import() #solo una vez  al instalar
font_import() #solo una vez  al instalar
loadfonts()
par(family = 'avenir')
plot(st_geometry(is2), col="burlywood4", border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber",bg = 'cyan')
plot(st_geometry(st_centroid(is2)),pch = 3, col = 'red', add = TRUE)
plot(st_cast(st_buffer(is2,100),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,300),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,400),"MULTILINESTRING"), col = 'darkblue', add = TRUE)
text(st_coordinates(is2_c), labels = nom_I, pos = 4)
blogdown:::serve_site()
library(ggplot2)
library(ggplot2)
library(ggspatial)
library(ggplot2)
library(ggspatial)
library(sp)
torrevieja <- data.frame(lon = c(-0.69,-0.67,-0.685,-0.681),
lat = c(37.98,37.97,37.978,37.975))
torrevieja <- data.frame(lon = c(-0.69,-0.67,-0.685,-0.681),
lat = c(37.98,37.97,37.978,37.975))
# Convertimos la tabla de puntos en capa espacial con sp
capa_puntos<-SpatialPoints(torrevieja)
# Convertimos la tabla de puntos en capa espacial con sp
capa_puntos<-SpatialPoints(torrevieja)
# asignamos un sistema de coordenaas
sp::proj4string(capa_puntos) <- CRS("+init=epsg:4326")
# Convertimos la tabla de puntos en capa espacial con sp
capa_puntos<-SpatialPoints(torrevieja)
# asignamos un sistema de coordenaas
sp::proj4string(capa_puntos) <- CRS("+init=epsg:4326")
# pintamos el mapa con ggplot y ggspatial
ggplot()+
ggtitle("Plano Torrevieja con puntos de interés")+
annotation_map_tile(type = "osm",zoom=15)+
layer_spatial(capa_puntos,size = 8, col="red",alpha = 0.5)+
annotation_scale(location = "br")+ # pinta leyenda
annotation_north_arrow(location = "tr", which_north = "true",
style = north_arrow_fancy_orienteering,
height = unit(1.5, "cm"),
width = unit(1.5, "cm"))
# cargamos maptools para datos de ejemplo
# library(maptools)
# hacemos esto para cargar sin mensajes
suppressMessages(library(maptools, warn.conflicts = F))
# cargamos los contornos mundiales
data("wrld_simpl")
# pintamos la zona de España y mediterráneo
plot(wrld_simpl, xlim=c(-4,2), ylim=c(30, 47))
# Usando prettymapr odemos añadir mas cosa al plot
library(prettymapr)
addscalebar()
# cargamos los contornos mundiales
data("wrld_simpl")
addscalebar()
# pintamos la zona de España y mediterráneo
plot(wrld_simpl, xlim=c(-4,2), ylim=c(30, 47))
addscalebar()
addnortharrow(pos = "topleft")
# pintamos la zona de España y mediterráneo
plot(wrld_simpl, xlim=c(-4,2), ylim=c(30, 47),col=rainbow(12))
addscalebar()
addnortharrow(pos = "topleft")
blogdown:::insert_image_addin()
blogdown:::serve_site()
library(DiagrammeR)
# diagrama de flujo de la librería
DiagrammeR("graph TD;
A(pol_cero)-->B[div_pol];
C(puntomedio)-->B;
B-->E[crea_isla];
style C fill:cyan;"
)
#rm(list=ls(all=TRUE))
# Crea poligono aleatorio de n vertices y diámetro medio R
pol_cero<-function(R=3000,nvert=5){
# R= diametro medio de la isla en m
I<- R/2 # Amplitud de desviación media de irregularidades
#N<-N # número de puntos base del boceto siempre <20
paso<-2*pi/nvert
# creamos poligono inicial como data.frame
pol_coord<-data.frame(x=NA,y=NA)
a<-runif(1,0.5,10) # añadimos una funcion seno a la amplitud
b<-runif(1,0.5,10) # añadimos otra funcion seno a la amplitud
for(i in 1:nvert-1){
#x<-(R+rnorm(1,I,I/3))*cos(paso*i)
#y<-(R+rnorm(1,I,I/3))*sin(paso*i)
x<-abs((R+I*sin(paso*i*a)+I*sin(paso*i*b)))*cos(paso*i)
y<-abs((R+I*sin(paso*i*a)+I*sin(paso*i*b)))*sin(paso*i)
pol_coord<-rbind(pol_coord,c(x,y))
}
pol_coord<-na.omit(pol_coord)
# Añadimos al final el punto origen para cerrar el poligono
pol_coord<-rbind(pol_coord,c(pol_coord[1,1],pol_coord[1,2]))
return(pol_coord)
}
#plot(pol_cero(,7),type="l")
# Creamos la función punto medio
puntomedio<-function(x1,y1,x2,y2){
# calcula el punto medio del lado y lo mueve
# un porcentaje aleatorio sobre al perpendicular del lado
xmed<-(x1+x2)/2
ymed<-(y1+y2)/2
# calculamos la tangente para sacar la perpendicular
vx<- -(y2-y1) # por anlgulos es el eje opuesto
vy<-(x2-x1)
# Este parametro d es importante y marca la desviación
# del nuevo punto respecto al lado
d<-0.2*runif(1,-1,1)
# coord del nuevo punto medio final
x0<-xmed+d*vx
y0<-ymed+d*vy
return(c(x0,y0))
}
# Función que divide en 2 cada lado del poligono
# los datos de entrada deben ser un data.frame
div_pol<-function(poligon){
n_pol<-data.frame(x=NA,y=NA)
# aplicamos la funión de punto medio
for (i in 1:nrow(poligon)-1){
n_pol<-rbind(n_pol,c(poligon[i,1],poligon[i,2]))
n_pol<-rbind(n_pol,puntomedio(poligon[i,1],poligon[i,2],
poligon[i+1,1],poligon[i+1,2]))
#n_pol<-rbind(n_pol,c(poligon[i+1,1],poligon[i+1,2]))
#esto era el fallo, se duplicaba la coordenada en el bucle
}
n_pol<-rbind(n_pol,c(poligon[nrow(poligon),1],poligon[nrow(poligon),2]))
n_pol<-na.omit(n_pol)
return(n_pol)
}
#2. funcion recursiva
div_pol_n<-function(poligon, N){
z<-poligon
for(i in 1:N){
z<- div_pol(z)
}
return(z)
}
# plot(div_pol_n(pol_cero(,3),5),type="l")
# Funcion final que devuelve el poligono de una isla
# aleaoria en formato poligono x-y
crea_isla<-function(R=5000,nver=6,N=5){
z<-pol_cero(R,nver)
z<-div_pol_n(z,N)
return(z)
}
library(DiagrammeR)
# diagrama de flujo de la librería
DiagrammeR("graph LR;
A(pol_cero)-->B[div_pol];
C(puntomedio)-->B;
B-->E1((crea_isla));
E1-->E2[pol_to_sf];
E2-->E[validar_contorno];
H[multipol_a_uno]-->E;
I[isla_chica]-->B1;
E-->I;
I-->E1;
B1[archipielago]-->I;
B1-->B2(junta_igran_archi);
B2-->F;
B1-->C1;
C1[nom_islas]-->F;
E11[p_interes]-->F((pinta_mapa));
E-->E11;
style E1 fill:cyan;
style F fill:Lime;
style B1 fill:orange;
style I fill:pink"
)
# para usar otras caligrafias
library(extrafont)
#font_import() solo una vez tras instalar
loadfonts() # carga llas fuentes
################################################
# Funciones para hacer un mapa del tesoro con R
# Autor: Fernando Villalba Bergado
# Fecha: 2018-2019
################################################
require(extrafont)
library(tidyverse)
library(sf)
# Funcion pol_to_sf:
# para transformar el poligono en objeto o capa espacial sf
# por defecto coge el CRS epsg 25831
pol_to_sf<-function(pol,epsg=25831){
capa <- pol %>%
st_as_sf(coords = c("x", "y"), crs = epsg) %>%
summarise(geometry = st_combine(geometry)) %>%
st_cast("POLYGON")
st_crs(capa)<-epsg
return(capa)
}
# Funcion validar_contorno:
# sirve para corregir fallos en los poligonos en los que cruzan lados
validar_contorno<-function(pol){
str1<-st_crs(pol)
if(is.na(str1)){str1=25831}
#    pol<-st_cast(pol,"POLYGON")
if(!st_is_valid(pol)){
pol<-st_buffer(pol, 10)# crea un buffer
pol<-st_combine(pol)
st_crs(pol)<-str1#25831
}
# comprueba que no es multipol
if(class(pol)[[1]]=="sfc_MULTIPOLYGON"){
pol<-multipol_a_uno(pol)
st_crs(pol)<-str1
}
return(pol)
}
## Función que coje solo el poligono de mayor área de un multipol
multipol_a_uno<-function(mpol){
aux1<-st_cast(mpol,"POLYGON")
#  aux1<-st_cast(aq,"POLYGON")
areas<-st_area(aux1)
aux2<-data.frame(area=areas,id=1:length(areas))
#selecciona la de mayor area
solo1<-head(aux2[order(aux2$area,decreasing = T),2],1)
# selecciona solo la de mayor area
aux3<-st_sf(st_geometry(aux1)[solo1])
return(aux3)
}
# prueba de las funciones
isla_prueba<-crea_isla(R=5000)%>% pol_to_sf()%>%validar_contorno()
plot(isla_prueba,axes=T,
main="Polígono-isla generada aleatoriamente",
graticule=T,bg="aliceblue",col="antiquewhite4",
family="Calibri")
################################################
# Funciones para hacer un mapa del tesoro con R
# Autor: Fernando Villalba Bergado
# Fecha: 2018-2019
################################################
require(extrafont)
require(prettymapr)
require(tidyverse)
require(sf)
# 2. Función que crear una isla chica de radio r
#  y la posiciona en la costa de la isla grande
isla_chica<-function(islagrande,r){
ichi<-crea_isla(R=r)%>% pol_to_sf()%>%validar_contorno()
# Posicion de la isla en el bufer
posi_ichi <- st_buffer(st_geometry(islagrande),r*2)
# Mueve la isla peq a un punto aleatorio del buffer
n<-dim(st_coordinates(posi_ichi))
dado<-as.integer(runif(1,1,n))# num aleatorio entre la dim de dado
# vector desplazamiento
x_chica<-st_coordinates(posi_ichi)[dado,1]
y_chica<-st_coordinates(posi_ichi)[dado,2]
# nuevo punto donde mover la isla chica
p = st_point(c(x_chica,y_chica))
#convierto el punto en geometria sfc
p<-st_sfc(p, crs = 25831)
#convierto la geometria en sf
p<-st_sf(p)
#sumo las geometrias sf es decir,
# desplazamos el poligono al punto
aux<-ichi+p
# por si acaso convierto en sf
aux<-st_sf(aux,crs = 25831)
return(aux)
}
# 3. funcion que generea varias islas, un archipielago
# devuelve una lista con las islas y el numero de estas
archipielago<-function(zona,radio=5000,n_islas=NA){
# generamos unas islas chicas
n_islas<-ifelse(is.na(n_islas),as.integer(runif(1,2,5)),n_islas )
archi<-list()# vacia la lista
# crea el poligono de buffer al que va sumando islas
todas_las_islas<-zona # el primero con la isla grande
#todas_las_islas<-validar_contorno(todas_las_islas)
# bucle que crea las islas
for(i in 1:n_islas){
# calucla un radio aleatorio de la isla chica
# como media 1/10 de la grande
r_isla<-radio/(runif(1,8,11))
# calcula el bufer del contorno
contorno<-st_buffer(todas_las_islas,(r_isla+500))
# Llama a la función isla_chica
archi[[i]]<-isla_chica(contorno,r_isla) %>% st_sf()
#valida el contorno
archi[[i]]<-validar_contorno(archi[[i]])
#une las islas para crear el nuevo contorno
todas_las_islas<-st_union(todas_las_islas,archi[[i]])
}
# devuelve una lista de 2
#aux<-list(archi,n_islas)
return(archi)
}
# Funcion junta_igran_archi
# junta la isla principal y el archipielago de islas chicas
junta_igran_archi<-function(igrande, archi){
#archi<-a
#igrande<-islagrande
n_islas<-length(archi)
# añado a la lista la islagrade
archi[[n_islas+1]]<-igrande
# unimos todas las islas de la lista archi
islas <-purrr::reduce(archi,st_union)
# Dividimos en poligonos cerrados
islas<-st_cast(islas,"POLYGON")
return(islas)
}
# Funcion nom_islas:
# da nombre a las islas aleatorias de entre los de la lista de la funcion
nom_islas<-function(n_islas){
nombres_islas<-c("Cabeza Rota","I. Pájaros",
"Isla Chica", "Islote de los Naúfragos",
"I. Esperanza", "I. Capitán Vilber",
"Isla Soledad","Peñón de la Negra",
"Punta del Moro")
# seleccion de los nombres anteriores unos aleatorios
# según el número de islitas
nom_I<-sample(nombres_islas,n_islas)
# Añadimos el nombre de la isla grande
nom_I<-c(nom_I,"Isla Perdida" )
return(nom_I)
}
# Funcion  p_interes:
# Crea una capa de puntos de interes en la isla.
# 2 puntos vip
# 1 playa
# 2 cabos
# la funcion devuelve una lista con 3 objetos:
#   puntos_vip,puntos_cabo,ruta_pirata
p_interes<-function(islagrande){
# calculo la linea de costa isla grande
lin_costa<-st_cast(islagrande,"LINESTRING")
#borra los puntos
puntos_vip<-NULL
puntos_cabo<-NULL
punto_1<-NULL
# Puntos interiores
npuntos<-2
# ojo que esta funcion st_sample muchas veces no devuelve el num especificado en size,
# por eso voy a calcular 2 mas y me quedo con los 2 primeros.
puntos_vip<-st_sample(st_buffer(islagrande,-200),size=npuntos+3)
puntos_vip<-st_sf(puntos_vip)
puntos_vip<-puntos_vip[1:npuntos,]
# Punto enlinea de costa para playa
npuntos<-1
punto_1<-st_sample(lin_costa,size=npuntos+2,type="random")
punto_1<-st_sf(punto_1)
punto_1<-st_cast(punto_1,"POINT")
punto_1<-punto_1[1,] # por quedarme solo con 1
# Unimos los 3
puntos_vip<-st_union(punto_1,puntos_vip)
puntos_vip<-st_difference(st_cast(puntos_vip,"POINT"))
# Asignamos los nombres de los puntos
puntos_vip$nombre<-c("Playa Mosquito","Palmera Alta","Tesoro")
# Cabos
# simplificamos el contorno mucho para identificar vertices
cape<-st_simplify(islagrande,dTolerance =2000)#(radio-1000))
# convierto a linea
cape<-st_cast(cape,"LINESTRING")
# convierto a puntos
cape<-st_cast(cape,"POINT")
#st_crs(cape)
npuntos<-2
puntos_cabo<-st_sample(cape,size=npuntos+2,type="random")
puntos_cabo<-st_cast(puntos_cabo,"POINT")
puntos_cabo<-st_sf(puntos_cabo)
puntos_cabo<-puntos_cabo[1:npuntos,] # por quedarme solo con 2
puntos_cabo$nombre<-sample(c("Cabo Tormentas", "Cabo de la Desesperanza",
"Punta Negra","Punta de las flechas"),npuntos)
# creo una linea on la ruta del tesoro
ruta_pirata<-st_cast(st_combine(puntos_vip), "LINESTRING")
aux<-list(puntos_vip,puntos_cabo,ruta_pirata)
return(aux)
}
# Funcion pinta_mapa:
#   pinta el mapa completo del tesoro en plot base
pinta_mapa_negro<-function(is2,nom_I,p_int){
#Calcula el centroide de cada isla
is2_c<-st_centroid(is2,of_largest_polygon = FALSE)
# Pintamos todo
# pinta las islas
plot(st_geometry(is2), col="black", border = "black",  axes = TRUE, main="Mapa del tesoro del capitán Vilber", bg="gray81",family="Old English Text MT")  #darkslategray1
# Pinta los centroides
plot(st_geometry(st_centroid(is2)),pch = 3, col = 'white', add = TRUE)
# Pinta las lineas e costa del mar
plot(st_cast(st_buffer(is2,50),"MULTILINESTRING"), col = 'gray20', add = TRUE)
plot(st_cast(st_buffer(is2,100),"MULTILINESTRING"), col = 'gray23', add = TRUE)
plot(st_cast(st_buffer(is2,300),"MULTILINESTRING"), col = 'gray29', add = TRUE)
plot(st_cast(st_buffer(is2,500),"MULTILINESTRING"), col = 'gray32', add = TRUE)
# Etiquetas de las islas
text(st_coordinates(is2_c), labels = nom_I, pos = 4,family="Old English Text MT",col = 'white')
# Puntos de interes
plot(p_int[[1]],add=T,pch=4,cex=2,lwd=2,col="gray42")
plot(p_int[[2]],add=T,col="red",pch=4,cex=2)
plot(p_int[[3]],add=T, col="red",lwd=2,lty=2)
#Etiquetas de los puntos de interes
text(st_coordinates(p_int[[1]]), labels = p_int[[1]]$nombre, pos = 4,family="Old English Text MT",col = 'white',cex=0.9)
text(st_coordinates(p_int[[2]]), labels = p_int[[2]]$nombre, pos = 4,family="Old English Text MT",col = 'white',cex=0.7)
# añade escala y norte
addscalebar()#(style="ticks")
addnortharrow(pos = "topright", scale = 0.5)
}
################################################
# Funciones para hacer un mapa del tesoro con R
# Autor: Fernando Villalba Bergado
# Fecha: 2018-2019
################################################
mapa_tesoro<-function(){
radio<-10000
#crea una isla principal
islagrande<-crea_isla(R=radio)%>% pol_to_sf()%>%validar_contorno()
# crea archipielago
a<-archipielago(islagrande,radio=radio)
#junta las islas
islas1<-junta_igran_archi(islagrande,a)
#da los nombres y los punto de interes
nom_I<-nom_islas(length(a))
pun_int<-p_interes(islagrande)
#pinta_mapa(is2,nom_I)
aux<-pinta_mapa_negro(islas1,nom_I,pun_int)
return(aux)
}
mapa_tesoro()
################################################
# Funciones para hacer un mapa del tesoro con R
# Autor: Fernando Villalba Bergado
# Fecha: 2018-2019
################################################
pinta_mapa_color<-function(is2,nom_I,p_int,col="darkseagreen4"){
#Calcula el centroide de cada isla
is2_c<-st_centroid(is2,of_largest_polygon = FALSE)
# Pintamos todo
# pinta las islas
plot(st_geometry(is2), col=col, border = "burlywood4",  axes = TRUE, main="Mapa del tesoro del capitán Vilber", bg="darkslategray1",family="Old English Text MT")  #darkslategray1
# Pinta los centroides
plot(st_geometry(st_centroid(is2)),pch = 3, col = 'gray0', add = TRUE)
# Pinta las lineas e costa del mar
plot(st_cast(st_buffer(is2,100),"MULTILINESTRING"), col = 'deepskyblue1', add = TRUE)
plot(st_cast(st_buffer(is2,200),"MULTILINESTRING"), col = 'deepskyblue2', add = TRUE)
plot(st_cast(st_buffer(is2,400),"MULTILINESTRING"), col = 'deepskyblue3', add = TRUE)
plot(st_cast(st_buffer(is2,800),"MULTILINESTRING"), col = 'deepskyblue4', add = TRUE)
# Etiquetas de las islas
text(st_coordinates(is2_c), labels = nom_I, pos = 4,family="Old English Text MT",col = 'gray8')
# Puntos de interes
plot(p_int[[1]],add=T,pch=4,cex=2,lwd=2,col="darkred")
plot(p_int[[2]],add=T,col="red",pch=4,cex=2)
plot(p_int[[3]],add=T, col="red",lwd=2,lty=2)
#Etiquetas de los puntos de interes
text(st_coordinates(p_int[[1]]), labels = p_int[[1]]$nombre, pos = 4,family="Old English Text MT",col = 'darkred',cex=1.3)
text(st_coordinates(p_int[[2]]), labels = p_int[[2]]$nombre, pos = 4,family="Old English Text MT",col = 'gray3',cex=0.8)
# añade escala y norte
addscalebar()#(style="ticks")
addnortharrow(pos = "topright", scale = 0.5)
}
mapa_tesoro_c<-function(color_islas='navajowhite4'){
radio<-10000
#crea una isla principal
islagrande<-crea_isla(R=radio)%>% pol_to_sf()%>%validar_contorno()
# crea archipielago
a<-archipielago(islagrande,radio=radio)
#junta las islas
islas1<-junta_igran_archi(islagrande,a)
#da los nombres y los punto de interes
nom_I<-nom_islas(length(a))
pun_int<-p_interes(islagrande)
#pinta_mapa(is2,nom_I)
aux<-pinta_mapa_color(islas1,nom_I,pun_int,color_islas)
return(aux)
}
#plot(st_simplify(islagrande,dTolerance =2000,add=T))
mapa_tesoro_c()
mapa_tesoro_c("salmon4")
mapa_tesoro_c()
mapa_tesoro_c()
mapa_tesoro_c("salmon4")
mapa_tesoro()
mapa_tesoro()
mapa_tesoro()
mapa_tesoro()
mapa_tesoro()
blogdown:::serve_site()
blogdown:::insert_image_addin()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
