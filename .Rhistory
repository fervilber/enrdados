}
islagrande<-pol_to_sf(islagrande)
plot(islagrande, col="red")
posi_ichi <- st_buffer(islagrande,500)
plot(posi_ichi)
# 2. Función que crear una isla chica de radio r
#  y la posiciona en la costa de la isla grande
isla_chica<-function(islagrande,r){
require(sf)
#r=1000
ichi<-crea_isla(R=r)
ichi<-pol_to_sf(ichi)
posi_ichi <- st_buffer(st_geometry(islagrande),r*2)
#      plot(islagrande,col="grey")
#    plot(posi_ichi,add=T)
#      plot(ichi,add=TRUE)
#      plot(posi_ichi,add=TRUE)
#      plot(ichi,add=TRUE)
#      plot(a1,add=TRUE)
#Mueve la isla peq a un punto aleatorio del buffer
n<-dim(st_coordinates(posi_ichi))
dado<-as.integer(runif(1,1,n))# num aleatorio entre la dim de daoo
# vector desplazamiento
x_chica<-st_coordinates(posi_ichi)[dado,1]
y_chica<-st_coordinates(posi_ichi)[dado,2]
# nuevo punto donde mover la isla chica
p = st_point(c(x_chica,y_chica))
#convierto el punto en geometria sfc
p<-st_sfc(p, crs = 25831)
#convierto la geometria en sf
p<-st_sf(p)
#sumo las geometrias sf
# igual a desplazar el pologono
#ichi
aux<-ichi+p
#aux<-st_sfc(aux, crs = 25831)
#plot(aux)
aux<-st_sf(aux,crs = 25831)
return(aux)
}
# 3. funcion que generea varias islas
archipielago<-function(zona,radio=5000,n_islas=NA){
# generamos unas islas chicas
#n_islas<-NA
n_islas<-ifelse(is.na(n_islas),as.integer(runif(1,2,5)),n_islas )
archi<-list()
todas_las_islas<-islagrande#zona
todas_las_islas<-validar_contorno(todas_las_islas)
#plot(todas_las_islas)
#st_crs(islagrande)
#st_crs(archi[[1]])
# plot(islagrande)
for(i in 1:n_islas){
#i=1
r_isla<-radio/(runif(1,8,11))
contorno<-st_buffer(todas_las_islas,(r_isla+500))
#plot(contorno, add=T)
archi[[i]]<-isla_chica(contorno,r_isla) %>% st_sf()
#plot(archi[[2]],add=T,col="red")
#archi[[i]]$nombre<-nom_I[i]
archi[[i]]<-validar_contorno(archi[[i]])
todas_las_islas<-st_union(todas_las_islas,archi[[i]])
# todas_las_islas<-st_combine(todas_las_islas,archi[[i]])
#st_crs(todas_las_islas)
#plot(todas_las_islas,add=T)
}
aux<-list(archi,n_islas)
return(aux)
}
a<-archipielago(islagrande,radio=radio)
#unimos todas las islas que estan en una lista
# pero hay que comrobar que no se crean multipolygon
if(length(a[[1]])!=a[[2]][1]){
quita_trozos<-data.frame(area=mapply(st_area,a[[1]]),id=1:length(a[[1]]))
solo<-head(quita_trozos[order(quita_trozos$area,decreasing = T),2],a[[2]][1])
n_islas<-a[[2]][1]
a<-a[[1]][solo]
}else{
n_islas<-a[[2]][1]
a<-a[[1]]
}
# añado a la lista la islagrade
a[[n_islas+1]]<-islagrande
islas <-purrr::reduce(a,st_union)
islas<-validar_contorno(islas)
#plot(islas)
# dividimos en poligonos cerrados
islas1<-st_cast(islas,"POLYGON")
# si salen mas de n_islas es que se ha colado algún fleco
# lo borramos con esto
if(dim(islas1)[1]!=n_islas){
quita_trozos<-data.frame(area=st_area(islas1),id=1:dim(islas1)[1])
solo<-head(quita_trozos[order(quita_trozos$area,decreasing = T),2],n_islas+1)
islas1_n<-st_sf(st_geometry(islas1)[solo])
islas1<-NULL
islas1<-islas1_n
}
#plot(islas1)
#plot(islas1,col=rainbow(8))#,add=T)
#contorno<-st_buffer(islagrande,500)
#plot(contorno,add=T)
#islagrande<-validar_contorno(islagrande)
#  lenght(islas1)
# unimoslas islas chicas y la grande
#st_union(st_cast(islas1, "MULTIPOLYGON"),islagrande)
#q1<-st_disjoint(islas1,islagrande)
#plot(q1)
#is<-st_union(islas1,islagrande,by_feature = T)
is2<-st_cast(islas1,"POLYGON")
#  plot(islas1)
#  st_area(is2)
is2_c<-st_centroid(is2,of_largest_polygon = FALSE)
#plot(is2,col=rainbow(9),axes = TRUE, graticule = TRUE)
nombres_islas<-c("Cabeza Rota","I. Pájaros", "Isla Chica", "Islote de los Naúfragos", "I. Esperanza", "I. Capitán Vilber","Isla Soledad")
nom_I<-sample(nombres_islas,n_islas)
#nom_I<-sample(nombres_islas,length(islas1_centro)-1)
nom_I<-c("Isla Perdida",nom_I )
# nombres de islas
#  nombres_islas<-c("Cabeza Rota","I. Pájaros", "Isla Chica", "Islote de los Naúfragos", "I. Esperanza", "I. Capitán Vilber","Isla Soledad")
#      nom_I<-sample(nombres_islas,num_islas)
#plot(st_coordinates(is2_c))
#plot(st_geometry(is2_c),col="burlywood4",axes = TRUE, graticule = TRUE)
#plot(st_geometry(is2),add=T)
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
plot(st_geometry(is2), col="burlywood4", border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
plot(st_geometry(st_centroid(is2)),pch = 3, col = 'red', add = TRUE)
plot(st_cast(st_buffer(is2,300),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,500),"MULTILINESTRING"), col = 'blue', add = TRUE)
text(st_coordinates(is2_c), labels = nom_I, pos = 4)
#library(ggplot2)
#library(sp)
library(tidyverse)
library(sf)
#library(ggspatial)
#library(rgeos) # gbuffer
# para usar otras caligrafias
#library(extrafont)
#font_import() solo una vez  al instalar
#loadfonts()
#loadfonts(device = "win")
# 1 creamos la isla grande
radio=6000 # radio medio de las isla grandem
islagrande<-crea_isla(R=radio)
validar_contorno<-function(pol){
if(!st_is_valid(pol)){
pol<-st_buffer(pol, 0.0)
pol<-st_combine(pol)
st_crs(pol)<-25831
}
return(pol)
}
islagrande$nombre<-"Isla Perdida"
#islagrande<-validar_contorno(islagrande)
#  if(!st_is_valid(islagrande)){
#    islagrande<-st_buffer(islagrande, 0.0)
#    islagrande<-st_combine(islagrande)
#  }
#   z1<-z#+c(100000) añadir dsplazamiento
## version 2
#funcion para transformar el poligono en objeto o capa espacial sf
# por defecto coge el CRS epsg 25831
pol_to_sf<-function(pol,epsg=25831){
capa <- pol %>%
st_as_sf(coords = c("x", "y"), crs = epsg) %>%
summarise(geometry = st_combine(geometry)) %>%
st_cast("POLYGON")
st_crs(capa)<-25831
return(capa)
}
islagrande<-pol_to_sf(islagrande)
plot(islagrande, col="red")
posi_ichi <- st_buffer(islagrande,500)
plot(posi_ichi)
# 2. Función que crear una isla chica de radio r
#  y la posiciona en la costa de la isla grande
isla_chica<-function(islagrande,r){
require(sf)
#r=1000
ichi<-crea_isla(R=r)
ichi<-pol_to_sf(ichi)
posi_ichi <- st_buffer(st_geometry(islagrande),r*2)
#      plot(islagrande,col="grey")
#    plot(posi_ichi,add=T)
#      plot(ichi,add=TRUE)
#      plot(posi_ichi,add=TRUE)
#      plot(ichi,add=TRUE)
#      plot(a1,add=TRUE)
#Mueve la isla peq a un punto aleatorio del buffer
n<-dim(st_coordinates(posi_ichi))
dado<-as.integer(runif(1,1,n))# num aleatorio entre la dim de daoo
# vector desplazamiento
x_chica<-st_coordinates(posi_ichi)[dado,1]
y_chica<-st_coordinates(posi_ichi)[dado,2]
# nuevo punto donde mover la isla chica
p = st_point(c(x_chica,y_chica))
#convierto el punto en geometria sfc
p<-st_sfc(p, crs = 25831)
#convierto la geometria en sf
p<-st_sf(p)
#sumo las geometrias sf
# igual a desplazar el pologono
#ichi
aux<-ichi+p
#aux<-st_sfc(aux, crs = 25831)
#plot(aux)
aux<-st_sf(aux,crs = 25831)
return(aux)
}
# 3. funcion que generea varias islas
archipielago<-function(zona,radio=5000,n_islas=NA){
# generamos unas islas chicas
#n_islas<-NA
n_islas<-ifelse(is.na(n_islas),as.integer(runif(1,2,5)),n_islas )
archi<-list()
todas_las_islas<-islagrande#zona
todas_las_islas<-validar_contorno(todas_las_islas)
#plot(todas_las_islas)
#st_crs(islagrande)
#st_crs(archi[[1]])
# plot(islagrande)
for(i in 1:n_islas){
#i=1
r_isla<-radio/(runif(1,8,11))
contorno<-st_buffer(todas_las_islas,(r_isla+500))
#plot(contorno, add=T)
archi[[i]]<-isla_chica(contorno,r_isla) %>% st_sf()
#plot(archi[[2]],add=T,col="red")
#archi[[i]]$nombre<-nom_I[i]
archi[[i]]<-validar_contorno(archi[[i]])
todas_las_islas<-st_union(todas_las_islas,archi[[i]])
# todas_las_islas<-st_combine(todas_las_islas,archi[[i]])
#st_crs(todas_las_islas)
#plot(todas_las_islas,add=T)
}
aux<-list(archi,n_islas)
return(aux)
}
a<-archipielago(islagrande,radio=radio)
#unimos todas las islas que estan en una lista
# pero hay que comrobar que no se crean multipolygon
if(length(a[[1]])!=a[[2]][1]){
quita_trozos<-data.frame(area=mapply(st_area,a[[1]]),id=1:length(a[[1]]))
solo<-head(quita_trozos[order(quita_trozos$area,decreasing = T),2],a[[2]][1])
n_islas<-a[[2]][1]
a<-a[[1]][solo]
}else{
n_islas<-a[[2]][1]
a<-a[[1]]
}
# añado a la lista la islagrade
a[[n_islas+1]]<-islagrande
islas <-purrr::reduce(a,st_union)
islas<-validar_contorno(islas)
#plot(islas)
# dividimos en poligonos cerrados
islas1<-st_cast(islas,"POLYGON")
# si salen mas de n_islas es que se ha colado algún fleco
# lo borramos con esto
if(dim(islas1)[1]!=n_islas){
quita_trozos<-data.frame(area=st_area(islas1),id=1:dim(islas1)[1])
solo<-head(quita_trozos[order(quita_trozos$area,decreasing = T),2],n_islas+1)
islas1_n<-st_sf(st_geometry(islas1)[solo])
islas1<-NULL
islas1<-islas1_n
}
#plot(islas1)
#plot(islas1,col=rainbow(8))#,add=T)
#contorno<-st_buffer(islagrande,500)
#plot(contorno,add=T)
#islagrande<-validar_contorno(islagrande)
#  lenght(islas1)
# unimoslas islas chicas y la grande
#st_union(st_cast(islas1, "MULTIPOLYGON"),islagrande)
#q1<-st_disjoint(islas1,islagrande)
#plot(q1)
#is<-st_union(islas1,islagrande,by_feature = T)
is2<-st_cast(islas1,"POLYGON")
#  plot(islas1)
#  st_area(is2)
is2_c<-st_centroid(is2,of_largest_polygon = FALSE)
#plot(is2,col=rainbow(9),axes = TRUE, graticule = TRUE)
nombres_islas<-c("Cabeza Rota","I. Pájaros", "Isla Chica", "Islote de los Naúfragos", "I. Esperanza", "I. Capitán Vilber","Isla Soledad")
nom_I<-sample(nombres_islas,n_islas)
#nom_I<-sample(nombres_islas,length(islas1_centro)-1)
nom_I<-c("Isla Perdida",nom_I )
# nombres de islas
#  nombres_islas<-c("Cabeza Rota","I. Pájaros", "Isla Chica", "Islote de los Naúfragos", "I. Esperanza", "I. Capitán Vilber","Isla Soledad")
#      nom_I<-sample(nombres_islas,num_islas)
#plot(st_coordinates(is2_c))
#plot(st_geometry(is2_c),col="burlywood4",axes = TRUE, graticule = TRUE)
#plot(st_geometry(is2),add=T)
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
plot(st_geometry(is2), col="burlywood4", border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
plot(st_geometry(st_centroid(is2)),pch = 3, col = 'red', add = TRUE)
plot(st_cast(st_buffer(is2,300),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,500),"MULTILINESTRING"), col = 'blue', add = TRUE)
text(st_coordinates(is2_c), labels = nom_I, pos = 4)
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
plot(st_geometry(is2), col="burlywood4", border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber",bg = 'blue')
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
plot(st_geometry(is2), col="burlywood4", border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber",bg = cyan')
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
plot(st_geometry(is2), col="burlywood4", border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber",bg = 'cyan')
plot(st_geometry(st_centroid(is2)),pch = 3, col = 'red', add = TRUE)
plot(st_cast(st_buffer(is2,300),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,500),"MULTILINESTRING"), col = 'blue', add = TRUE)
text(st_coordinates(is2_c), labels = nom_I, pos = 4)
#library(ggplot2)
#library(sp)
library(tidyverse)
library(sf)
#library(ggspatial)
#library(rgeos) # gbuffer
# para usar otras caligrafias
#library(extrafont)
#font_import() solo una vez  al instalar
#loadfonts()
#loadfonts(device = "win")
# 1 creamos la isla grande
radio=6000 # radio medio de las isla grandem
islagrande<-crea_isla(R=radio)
validar_contorno<-function(pol){
if(!st_is_valid(pol)){
pol<-st_buffer(pol, 0.0)
pol<-st_combine(pol)
st_crs(pol)<-25831
}
return(pol)
}
islagrande$nombre<-"Isla Perdida"
#islagrande<-validar_contorno(islagrande)
#  if(!st_is_valid(islagrande)){
#    islagrande<-st_buffer(islagrande, 0.0)
#    islagrande<-st_combine(islagrande)
#  }
#   z1<-z#+c(100000) añadir dsplazamiento
## version 2
#funcion para transformar el poligono en objeto o capa espacial sf
# por defecto coge el CRS epsg 25831
pol_to_sf<-function(pol,epsg=25831){
capa <- pol %>%
st_as_sf(coords = c("x", "y"), crs = epsg) %>%
summarise(geometry = st_combine(geometry)) %>%
st_cast("POLYGON")
st_crs(capa)<-25831
return(capa)
}
islagrande<-pol_to_sf(islagrande)
plot(islagrande, col="red")
posi_ichi <- st_buffer(islagrande,500)
plot(posi_ichi)
# 2. Función que crear una isla chica de radio r
#  y la posiciona en la costa de la isla grande
isla_chica<-function(islagrande,r){
require(sf)
#r=1000
ichi<-crea_isla(R=r)
ichi<-pol_to_sf(ichi)
posi_ichi <- st_buffer(st_geometry(islagrande),r*2)
#      plot(islagrande,col="grey")
#    plot(posi_ichi,add=T)
#      plot(ichi,add=TRUE)
#      plot(posi_ichi,add=TRUE)
#      plot(ichi,add=TRUE)
#      plot(a1,add=TRUE)
#Mueve la isla peq a un punto aleatorio del buffer
n<-dim(st_coordinates(posi_ichi))
dado<-as.integer(runif(1,1,n))# num aleatorio entre la dim de daoo
# vector desplazamiento
x_chica<-st_coordinates(posi_ichi)[dado,1]
y_chica<-st_coordinates(posi_ichi)[dado,2]
# nuevo punto donde mover la isla chica
p = st_point(c(x_chica,y_chica))
#convierto el punto en geometria sfc
p<-st_sfc(p, crs = 25831)
#convierto la geometria en sf
p<-st_sf(p)
#sumo las geometrias sf
# igual a desplazar el pologono
#ichi
aux<-ichi+p
#aux<-st_sfc(aux, crs = 25831)
#plot(aux)
aux<-st_sf(aux,crs = 25831)
return(aux)
}
# 3. funcion que generea varias islas
archipielago<-function(zona,radio=5000,n_islas=NA){
# generamos unas islas chicas
#n_islas<-NA
n_islas<-ifelse(is.na(n_islas),as.integer(runif(1,2,5)),n_islas )
archi<-list()
todas_las_islas<-islagrande#zona
todas_las_islas<-validar_contorno(todas_las_islas)
#plot(todas_las_islas)
#st_crs(islagrande)
#st_crs(archi[[1]])
# plot(islagrande)
for(i in 1:n_islas){
#i=1
r_isla<-radio/(runif(1,8,11))
contorno<-st_buffer(todas_las_islas,(r_isla+500))
#plot(contorno, add=T)
archi[[i]]<-isla_chica(contorno,r_isla) %>% st_sf()
#plot(archi[[2]],add=T,col="red")
#archi[[i]]$nombre<-nom_I[i]
archi[[i]]<-validar_contorno(archi[[i]])
todas_las_islas<-st_union(todas_las_islas,archi[[i]])
# todas_las_islas<-st_combine(todas_las_islas,archi[[i]])
#st_crs(todas_las_islas)
#plot(todas_las_islas,add=T)
}
aux<-list(archi,n_islas)
return(aux)
}
a<-archipielago(islagrande,radio=radio)
#unimos todas las islas que estan en una lista
# pero hay que comrobar que no se crean multipolygon
if(length(a[[1]])!=a[[2]][1]){
quita_trozos<-data.frame(area=mapply(st_area,a[[1]]),id=1:length(a[[1]]))
solo<-head(quita_trozos[order(quita_trozos$area,decreasing = T),2],a[[2]][1])
n_islas<-a[[2]][1]
a<-a[[1]][solo]
}else{
n_islas<-a[[2]][1]
a<-a[[1]]
}
# añado a la lista la islagrade
a[[n_islas+1]]<-islagrande
islas <-purrr::reduce(a,st_union)
islas<-validar_contorno(islas)
#plot(islas)
# dividimos en poligonos cerrados
islas1<-st_cast(islas,"POLYGON")
# si salen mas de n_islas es que se ha colado algún fleco
# lo borramos con esto
if(dim(islas1)[1]!=n_islas){
quita_trozos<-data.frame(area=st_area(islas1),id=1:dim(islas1)[1])
solo<-head(quita_trozos[order(quita_trozos$area,decreasing = T),2],n_islas+1)
islas1_n<-st_sf(st_geometry(islas1)[solo])
islas1<-NULL
islas1<-islas1_n
}
#plot(islas1)
#plot(islas1,col=rainbow(8))#,add=T)
#contorno<-st_buffer(islagrande,500)
#plot(contorno,add=T)
#islagrande<-validar_contorno(islagrande)
#  lenght(islas1)
# unimoslas islas chicas y la grande
#st_union(st_cast(islas1, "MULTIPOLYGON"),islagrande)
#q1<-st_disjoint(islas1,islagrande)
#plot(q1)
#is<-st_union(islas1,islagrande,by_feature = T)
is2<-st_cast(islas1,"POLYGON")
#  plot(islas1)
#  st_area(is2)
is2_c<-st_centroid(is2,of_largest_polygon = FALSE)
#plot(is2,col=rainbow(9),axes = TRUE, graticule = TRUE)
nombres_islas<-c("Cabeza Rota","I. Pájaros", "Isla Chica", "Islote de los Naúfragos", "I. Esperanza", "I. Capitán Vilber","Isla Soledad")
nom_I<-sample(nombres_islas,n_islas)
#nom_I<-sample(nombres_islas,length(islas1_centro)-1)
nom_I<-c("Isla Perdida",nom_I )
# nombres de islas
#  nombres_islas<-c("Cabeza Rota","I. Pájaros", "Isla Chica", "Islote de los Naúfragos", "I. Esperanza", "I. Capitán Vilber","Isla Soledad")
#      nom_I<-sample(nombres_islas,num_islas)
#plot(st_coordinates(is2_c))
#plot(st_geometry(is2_c),col="burlywood4",axes = TRUE, graticule = TRUE)
#plot(st_geometry(is2),add=T)
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
plot(st_geometry(is2), col="burlywood4", border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber",bg = 'cyan')
plot(st_geometry(st_centroid(is2)),pch = 3, col = 'red', add = TRUE)
plot(st_cast(st_buffer(is2,300),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,500),"MULTILINESTRING"), col = 'blue', add = TRUE)
text(st_coordinates(is2_c), labels = nom_I, pos = 4)
plot(st_cast(st_buffer(is2,400),"MULTILINESTRING"), col = 'darkblue', add = TRUE)
plot(st_cast(st_buffer(is2,100),"MULTILINESTRING"), col = 'blue', add = TRUE)
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
par(family = ‘avenir’)
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
par(family = 'avenir')
plot(st_geometry(is2), col="burlywood4", border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber",bg = 'cyan')
plot(st_geometry(st_centroid(is2)),pch = 3, col = 'red', add = TRUE)
plot(st_cast(st_buffer(is2,100),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,300),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,400),"MULTILINESTRING"), col = 'darkblue', add = TRUE)
text(st_coordinates(is2_c), labels = nom_I, pos = 4)
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
quartzFonts(avenir = c(“Avenir Book”, “Avenir Black”, “Avenir Book Oblique”,
“Avenir Black Oblique”))
#  plot(st_geometry(is2), col = sf.colors(12, categorical = TRUE), border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber")
quartzFonts(avenir = c("Avenir Book", "Avenir Black", "Avenir Book Oblique" ,"Avenir Black Oblique"))
#library(ggspatial)
#library(rgeos) # gbuffer
# para usar otras caligrafias
library(extrafont)
install.packages("extrafont")
font_import() solo una vez  al instalar
#library(ggspatial)
#library(rgeos) # gbuffer
# para usar otras caligrafias
library(extrafont)
font_import() #solo una vez  al instalar
font_import() #solo una vez  al instalar
loadfonts()
par(family = 'avenir')
plot(st_geometry(is2), col="burlywood4", border = 'grey',  axes = TRUE, main="Mapa del tesoro del capitán Vilber",bg = 'cyan')
plot(st_geometry(st_centroid(is2)),pch = 3, col = 'red', add = TRUE)
plot(st_cast(st_buffer(is2,100),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,300),"MULTILINESTRING"), col = 'blue', add = TRUE)
plot(st_cast(st_buffer(is2,400),"MULTILINESTRING"), col = 'darkblue', add = TRUE)
text(st_coordinates(is2_c), labels = nom_I, pos = 4)
