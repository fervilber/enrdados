p3<-ggplot(data=tabla_encuesta, aes(x=C)) +
geom_bar(aes(fill=C),show.legend = FALSE)+
theme_cowplot(8)
g_encuesta<-(p1 + p2) /p3
g_encuesta+ plot_annotation(tag_levels = 'A',tag_prefix = 'Pregunta. ')
blogdown:::serve_site()
blogdown:::insert_image_addin()
blogdown:::new_post_addin()
knitr::opts_chunk$set(error=FALSE,echo = TRUE, warning = FALSE, message = FALSE)
#/post/2021-05-30-unir-graficas-en-una-imagen/images/pach1.png
# /post/2021-06-14-generacion-aleatoria/images/aleatorio.png'
library(tidyverse)
library(tidyverse)
library(stringr)
library(pdftools)
# leemos las paginas del pdf una a una y separamos por filas
fich_pdf<-pdf_text("Listado de notas Prep. 2021.pdf") %>%
str_split("\n")
# leemos las paginas del pdf una a una y separamos por filas
fich_pdf<-pdf_text("Listado de notas Prep. 2021.pdf") %>%
str_split("\n")
str(fich_pdf)
# numero de paginas leidas del documento
length(fich_pdf)
# numero de filas leidas por pag
lengths(fich_pdf)
head(fich_pdf)
head(fich_pdf[[1]])
head(fich_pdf[[1]],10)
# me quedo solo con líneas de datos de la tabla
#Ojo primero las de abajo para no cambiar la numeracion
fich_pdf[[1]] <- fich_pdf[[1]][-41:-46]
fich_pdf[[1]] <- fich_pdf[[1]][-1:-8]
# ahora la pagina 2
fich_pdf[[2]] <- fich_pdf[[2]][-13:-34]
fich_pdf[[2]] <- fich_pdf[[2]][-1:-4]
fich_pdf
head(fich_pdf)
#juntamos todo en un data frame
# quitamos espacios sobrantes con str_squish
aux<-unlist(fich_pdf) %>% str_squish()
#quito primera linea
aux<-aux[-1]
aux
#juntamos todo en un data frame
# quitamos espacios sobrantes con str_squish
aux<-unlist(fich_pdf) %>% str_squish()
aux
head(aux)
num<-aux %>% str_extract("[[:digit:]]+(?=\\.)")
num
aux
#quito primera linea
aux<-aux[-1]
aux %>% str_extract("[[:digit:]]+(?=\\.)")
aux
# almacenamos en el vector num los números de línea
num<-aux %>% str_extract("[[:digit:]]+(?=\\.)")
# sacamos los apellidos:
#     está precedido por . y espacio y finalizan con coma , mas un espacio
apellido<-aux %>% str_extract("(?<=\\.\\s)[[:print:]]+(?=\\,\\s)")
# quito las variables ya leidas del vector
aux1<-str_squish(substring(aux, first = 4))
aux1<-str_replace_all( aux1, apellido,"" )
# quito la coma y espacio
aux1<-substring(aux1, first = 3)
aux1
apellido
aux1
aux1<-aux1 %>% strsplit(split= " ")
nota<-map_chr(aux1,~.x[[1]])
nota
aux1
head(aux1)
walk(aux1,print)
head(aux1)
# quito las variables ya leidas del vector
aux1<-str_squish(substring(aux, first = 4))
aux1<-str_replace_all( aux1, apellido,"" )
# quito la coma y espacio
aux1<-substring(aux1, first = 3)
# Extraigo el nombre:
# el nombre comienza con la coma y espacio y finaliza con espacio y digito y coma seguidos
#nom<-aux %>% str_extract("(?<=\\,\\s)[[:print:]]+(?=[[:digit:]]\\,)")
# el nombre finaliza con espacio+digito+coma
nom<-aux1 %>% str_extract("[[:print:]]+(?=\\s[[:digit:]]\\,)")
aux1<-str_replace_all( aux1, nom,"" ) # lo quito de aux1 el nombre
aux1<-str_squish(aux1)
head(aux1)
walk(aux1,print)
head(aux1)
aux1
aux2<-aux1 %>% strsplit(split= " ")
aux2
unlist(aux2)
walk(aux2,print)
walk(aux2,print)[1:6]
walk(aux2,head)
walk(aux2,print)
walk(aux2,print,3)
walk(aux2[1:6],print)
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::insert_image_addin()
blogdown:::insert_image_addin()
install.packages(c("blogdown", "bookdown"))
install.packages(c("blogdown", "bookdown"))
blogdown:::new_post_addin()
blogdown:::insert_image_addin()
knitr::opts_chunk$set(error=FALSE,echo = TRUE, warning = FALSE, message = FALSE)
#/post/2021-05-30-unir-graficas-en-una-imagen/images/pach1.png
# '/post/2021-04-26-office-desde-r/images/pach2.png'
#funcion que pinta de manera iterativa las ramas
ramas<-function(pini, w, l, ang, lmin_rama=10,color="white") {
# pini= punto inicio linea rama c(x,y)
# w= ancho de la rama
# l= largo de la rama
# ang= angulo de la rama
# lmin_rama= limite min de long de rama recomendado h/50
x1 = pini[1] - l * cos(ang);
y1 = pini[2] + l * sin(ang);
pfin = c(x1, y1)
# color de las ramas que va aumentando el alfa en las hojas
col01<-adjustcolor(color,alpha.f = 1-lmin_rama/l)
# pinta la linea con los datos dados
lines(c(pini[1],pfin[1]),c(pini[2],pfin[2]),lwd=w,col=col01)
# Calcula la siguiente bifurcación:
dif<- pi/2 #- (pi / 16)
angle1<-ang+ runif(1,0,dif)/2
angle2<-ang- runif(1,0,dif)/2
# calcula aleatoriamente un nuevo grueso y largo de las ramas bifurcadas
n_ancho = runif(1,w * 0.6, w * 0.8);
n_largo = runif(1,l * 0.7, l * 0.9);
# Controla el crecimiento recursivo hasta el limite min de rama
if (n_largo < lmin_rama) {
# sale del loop, fin de función
}else { # pinta las nuevas ramas de la bifurcación
ramas(pfin, n_ancho, n_largo, angle1,lmin_rama,col=col01);
if(runif(1)>0.3){ # un 30% de las veces no se bifurcará
ramas(pfin, n_ancho, n_largo, angle2,lmin_rama,col=col01)
}
}
}
# función que pinta el arbol
parbol <- function(h = 100,ramificacion=50,base=h/2,colort="white", sobreescribe=NULL) {
# h = altura media del arbol
# base= posición de x0 del tronco en principio h/2
# ramificaciones = a mayor-->más ramas y más complejo
if (is.null(sobreescribe)) {
#pinta el lienzo en blanco
plot(1:h,type="n",
xlim = c(0,h),
ylim = c(0,h),
xlab = " ",ylab=" ")
}
# calculo de variables:
largo <- runif(1,h/10,h/5) # altura tronco
ancho <- sample(6:25,1)  # ancho tronco
angulo_rama = pi / 2 # angulo de rama inicial 90
# puntos xy de la linea del tronco principal
x1= base;   y1 = 0
x2 = base ; y2 = largo
# pintamos el tronco en las coordenadas x1,x2  y1,y2
# ajuste de color del arbol
col01<-adjustcolor(colort,alpha.f = 1)
abline(h=0,lwd=ancho/2, col=col01) #linea de suelo
# tronco base; lend indica la forma de extremo de linea (par)
lines(c(x1,x2),c(y1,y2),lwd=ancho,col=col01, lend=1)
angle1<-angulo_rama+ rnorm(1)*pi/16 # angulo de la siguiente parte del tronco
# Llama a la función de creación de las ramas a partir del punto
# final del tronco
ramas(c(x2,y2), ancho, largo, angle1,h/ramificacion,color=colort)
}
parbol(h,150,color="black")
parbol(100,150,color="black")
# Creo un arbol de altura 100
parbol(,150,color="black")
parbol(120,150,base=20,color="black",sobreescribe=1)
parbol(120,150,color="black")
parbol(120,150,base=20,color="black",sobreescribe=1)
par(bg = 'black')
parbol(120,150,color="white")
parbol(120,150,base=20,color="white",sobreescribe=1)
# Creo un arbol de altura 100
parbol(120,150,color="black")
blogdown:::serve_site()
####################################
######## Función que pinta el arbol
parbol <- function(h = 100,ramificacion=50,base=h/2,colort="white", sobreescribe=NULL) {
# h = altura media del arbol
# base= posición de x0 del tronco en principio h/2
# ramificaciones = a mayor-->más ramas y más complejo
if (is.null(sobreescribe)) {
#pinta el lienzo en blanco
plot(1:h,type="n",
xlim = c(0,h),
ylim = c(0,h),
xlab = " ",ylab=" ")
}
# calculo de variables:
largo <- runif(1,h/10,h/5) # altura tronco
ancho <- sample(6:25,1)  # ancho tronco
angulo_rama = pi / 2 # angulo de rama inicial 90
# puntos xy de la linea del tronco principal
x1= base;   y1 = 0
x2 = base ; y2 = largo
# pintamos el tronco en las coordenadas x1,x2  y1,y2
# ajuste de color del arbol
col01<-adjustcolor(colort,alpha.f = 1)
abline(h=0,lwd=ancho/2, col=col01) #linea de suelo
# tronco base; lend indica la forma de extremo de linea (par)
lines(c(x1,x2),c(y1,y2),lwd=ancho,col=col01, lend=1)
angle1<-angulo_rama+ rnorm(1)*pi/16 # angulo de la siguiente parte del tronco
# Llama a la función de creación de las ramas a partir del punto
# final del tronco
ramas(c(x2,y2), ancho, largo, angle1,h/ramificacion,color=colort)
}
####################################
######## Funcion que pinta las ramas
ramas<-function(pini, w, l, ang, lmin_rama=10,color="white") {
# pini= punto inicio linea rama c(x,y)
# w= ancho de la rama
# l= largo de la rama
# ang= angulo de la rama
# lmin_rama= limite min de long de rama recomendado h/50
x1 = pini[1] - l * cos(ang);
y1 = pini[2] + l * sin(ang);
pfin = c(x1, y1)
# color de las ramas que va aumentando el alfa en las hojas
col01<-adjustcolor(color,alpha.f = 1-lmin_rama/l)
# pinta la linea con los datos dados
lines(c(pini[1],pfin[1]),c(pini[2],pfin[2]),lwd=w,col=col01)
# Calcula la siguiente bifurcación:
dif<- pi/2 #- (pi / 16)
angle1<-ang+ runif(1,0,dif)/2
angle2<-ang- runif(1,0,dif)/2
# calcula aleatoriamente un nuevo grueso y largo de las ramas bifurcadas
n_ancho = runif(1,w * 0.6, w * 0.8);
n_largo = runif(1,l * 0.7, l * 0.9);
# Controla el crecimiento recursivo hasta el limite min de rama
if (n_largo < lmin_rama) {
# sale del loop, fin de función
}else { # pinta las nuevas ramas de la bifurcación
ramas(pfin, n_ancho, n_largo, angle1,lmin_rama,col=col01);
if(runif(1)>0.3){ # un 30% de las veces no se bifurcará
ramas(pfin, n_ancho, n_largo, angle2,lmin_rama,col=col01)
}
}
}
blogdown:::serve_site()
blogdown:::serve_site()
knitr::opts_chunk$set(error=FALSE,echo = TRUE, warning = FALSE, message = FALSE)
#![arbol generado con un algoritmo recursivo](images/ARBOL_DOBLE_RAMI01.png)
parbol(120,150,base=70,color="white")
parbol(120,150,base=20,color="darkred",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70,color="white")
parbol(90,150,base=20,color="darkred",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70,color="white")
parbol(90,150,base=20,color="red",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,100,base=20,color="grey",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,100,base=20,color="grey",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,100,base=20,color="grey",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,100,base=20,color="grey",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,100,base=20,color="white",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,100,base=20,color="white",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,200,base=20,color="white",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(90,200,base=20,color="white",sobreescribe=1)
par(bg = 'black')
parbol(120,150,base=70)
parbol(120,200,base=20,color="white",sobreescribe=1)
parbol(120,150)
parbol(120,200,sobreescribe=1)
par(bg = 'black')
parbol(120,150)
parbol(120,200,sobreescribe=1)
par(bg = 'black')
parbol(120,150)
parbol(120,200,sobreescribe=1)
# Ejemplo de diagrama de flujo SANKEY
library(networkD3)      # cargamos librería
# Definimos los nodos de la red, que se numeran automáticamente de 0 a ..
nodes = data.frame("name" =
c("Fuente clara",  # Node 0
"Bombeo 1",      # Node 1
"Ayt. Villalocos",  # Node 2
"Ayt. Torrecilla",         # Nodo 3
"C.RR 1",        # Nodo 4
"C.RR 2",        # Nodo 5
"Embalse alto",  # Nodo 6
"Ayt. Puerto Plata", # Nodo 7
"Ayt. Jerjes",   # Nodo 8
"Fuente Negra"   # Nodo 9
))
# Definimos ahora los flujos en la forma siguiente:
# nodo origen, nodo final, cantidad de flujo
links = as.data.frame(matrix(c(
0, 1, 53, # desde, a, cuanto
0, 3, 5,
0, 4, 10,
1, 3, 5,
1, 8, 3,
1, 5, 7,
1, 4, 5,
1, 6, 32,
6,2,25,
6,7,7,
6,3,2,
9,3,40,
9,1,3),
byrow = TRUE, ncol = 3))
# nombramos las columnas con los nombres estándar de la librería networkD3
names(links) = c("source", "target", "value")
# Llamamos a la funcion de dibujo del diagrama
sankeyNetwork(Links = links, Nodes = nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
fontSize= 10, nodeWidth = 50,nodePadding = 10,
colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"
)
)
# Descargamos los datos
URL <- paste0('https://cdn.rawgit.com/christophergandrud/networkD3/',
'master/JSONdata/energy.json')
energy <- jsonlite::fromJSON(URL)
#knitr::kable(head(energy),"html")
str(energy)
# Pintamos la grafica simple sin colorear flujos
sankeyNetwork(Links = energy$links, Nodes = energy$nodes, Source = 'source',
Target = 'target', Value = 'value', NodeID = 'name',
units = 'TWh', fontSize = 12, nodeWidth = 30)
# flujo coloreados
energy$links$energy_type <- sub(' .*', '',
energy$nodes[energy$links$source + 1, 'name'])
# los colores del flujo los definimos segun los valores de energy$links$energy_type
knitr::kable(head(energy$links$energy_type))
# pintamos la grafica con flujo coloreados
sankeyNetwork(Links = energy$links, Nodes = energy$nodes, Source = 'source',
Target = 'target', Value = 'value', NodeID = 'name',
LinkGroup = 'energy_type', NodeGroup = NULL)
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::new_post_addin()
blogdown:::serve_site()
blogdown:::insert_image_addin()
knitr::opts_chunk$set(error=FALSE,echo = TRUE, warning = FALSE, message = FALSE)
silaba(campana)
#####################################################
# Funciones para silabear una palabra en castellano #
# Autor: Fernando Villalba Bergado                  #
#        www.enRdados.net                           #
#####################################################
library(stringr)
# Función que es TRUE si es una vocal acentuada con tilde
tieneTilde <- function(c) {
c = tolower(c)
tildes = c("á", "é", "í", "ó", "ú")
if (c %in%  tildes) {
return(T)
} else{
return(F)
}
}
#Vocal= Funcion que determina si es o no vocal un caracter
Vocal <- function(c) {
V = T
c = tolower(c) #LCase(c)
vocales = c("a", "á", "e", "é", "i", "í", "o", "ó", "u", "ú", "ü")
if (c %in%  vocales) {
V = T
} else{
V = F
}
return(V)
}
# Funcion que dice si es vocal abierta o cerrada
TipoVocal <- function(c) {
# 0 = no es vocal
# 1 = vocal abierta
# -1 = vocal cerrada
V = 0 # si no es vocal
c = tolower(c) #pasa a minúscula
if (Vocal(c)) {
v_cerrada = c("i", "í", "u", "ú", "ü")
if (c %in%  v_cerrada) {
V = -1
} else{
V = 1
}
}
return(V)
#Ejemplo: TipoVocal("a")
}
# Letra = funcion que nos dice si es una letra = True o no (puede ser un símbolo)
Letra <- function(c) {
l = F
c = tolower(c) # pasa a minúscula
if ((c >= "a" &  c <= "z" | c == "ñ") |
(c == "á" |  c == "é" | c == "í" | c == "ó" | c == "ú" | c == "ü")
) {
l = T
} else{
l = F
}
return(l)
}
# Comb = funcion que nos dice si las letras seleccionadas son alguna de las combinaciones de consonantes marcadas
Comb <- function(c) {
Cmb = T
c = tolower(c)
combi <-
c("bl","br",
"cl","cr",
"dl","dr",
"fl","fr",
"gl","gr",
"pl","pr",
"tl","tr",
"kl","kr",
"ll","rr",
"ch","qu"
)
if (c %in%  combi) {
Cmb = T
} else{
Cmb = F
} #-1=cerrada
return(Cmb)
}
silabas <- function(miP) {
V = 0
S = ""
A = ""
Sig = ""
l = nchar(miP) #str_length(miP)
miP = str_trim(miP)
Va = F
silabas = c(NULL)
#if(miP !="palabra"){1}else{2}
if (miP != "") {
for (i in seq.int(from = l, to = 1)) {
Ta = F # T de antes
c = str_sub(miP, i, i) # c = substring(miP, i, i)
Vc = Vocal(c)
Vs = Vocal(Sig)
Tvc = TipoVocal(c)
Tvs = TipoVocal(Sig)
Cmb = paste0(c, Sig)
if (Vc & !Vs) {
V = V + 1
}
if (V > 1 & !Vs) {
Ta = T
}
else if ((!Vc & !Vs & !Comb(Cmb)) & (V = 1 & i > 1)) {
Ta = T
}
#  if((TipoVocal("a") == -1 & tieneTilde("í") & TipoVocal("í"))){1}
else if ((Tvc == 1 & Tvs == 1) |
(Tvc == -1 & tieneTilde(c) & Vs) |
(Tvc == 1 & (Tvs == -1 & tieneTilde(Sig))) |
((Vc & Vs) & (c == Sig))) {
Ta = T
V = V + 1
}
if (Ta == T) {
#Añade la nueva sílaba
if(S !=""){silabas = c(S, silabas)}
#silabas = c(S, silabas) #append(silabas,S)
S = c
V = V - 1
} else{
S = paste0(c, S)
}
Sig = c
}
#Añade la nueva sílaba
#silabas = c(S, silabas)
if(S !=""){silabas = c(S, silabas)}
} else{
return(F) # si no es correcto
}
return(silabas)
}
#silabasg = funcion que calcula las sílabas de una palabra separada por guiones
silabasg<-function(c){
paste(silabas(c),collapse="-")
}
silaba(campana)
silabas(campana)
blogdown:::serve_site()
blogdown:::serve_site()
