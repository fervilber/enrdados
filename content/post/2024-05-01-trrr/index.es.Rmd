---
title: trrr
author: F.VilBer
date: '2024-05-01'
slug: []
categories:
  - dise침o
tags:
  - dibujo
  - divertido
description: 'Creacion de partituras gr치ficas'
thumbnail: '/post/2024-05-01-trrr/images/circulos1.png'
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.height=4,warning = FALSE,message = FALSE)
```


## trrr..

Qu칠 mejor que retomar el blog con un gran arranque onomatop칠yico "trrr.." es el sonido de un temblor, de un rugido de moto, un arranque brutal... eso es lo que os propongo en este regreso tras una larga ausencia, empecemos!.

![partitura grafica](images/c27724a0-8455-4619-b606-205ea758710a.png)

Este juego m칰sico-visual se me ocurri칩 en Granada hace unos d칤as. Resulta que estaba paseando por esa bella ciudad y pasamos al patio del palacio de la Madraza, donde hab칤a una exposici칩n de los (*Escalona Brothers*)[https://lamadraza.ugr.es/evento/trrrr-escalona-brothers/].

En medio del bullicio nocturno de la ciudad, me encontr칠 de repente en un precioso patio de esos con encanto *granaino*. En la sala de exposiciones contigua encontr칠 tirado en el suelo un pobre piano maltrecho, destrozado, con su arpa sangrante y una invasi칩n de extra침os temblores s칩nicos.

Me llam칩 poderosamente la atenci칩n unos dibujos muy simples de c칤rculos y l칤neas en blanco y negro repartidos por la sala de exposiciones. Me qued칠 con uno de los folletos de la exposici칩n en los que pude leer, ya a la ma침ana siguiente, que se trataba de representaciones de "*partituras gr치ficas, compuestas por s칤mbolos inspirados en mapas de enjambres s칤smicos*".

![*Partitura grafica*](images/escalona.jpg)

No negar칠 que la elegante descripci칩n de sus creadores me dej칩 tocado 游땍, y fue en ese momento cuando pens칠 en hacer mi particular versi칩n de estas *"partituras gr치ficas"*, usando, claro est치, R.


![_*Muestra de partitura gr치fica creada con R*_](images/25b50787-2f29-41ec-b057-5c1a5178aac6.png)


Las im치genes de los hermanos Escalona muestran una composici칩n gr치fica abstracta en blanco y negro. En ellas hay una serie de c칤rculos negros conc칠ntricos de diferentes tama침os y estilos que parecen estar conectados por finas l칤neas, creando una estructura que podr칤a asemejarse a una red o un diagrama de conexiones. 

# De la idea al programa

El programa que voy a mostraros es el 칰ltimo de una serie de pruebas que paso a paso han ido conform치ndose hasta crear las funciones y flujo final, aunque b치sicamente mantienen la primera idea original que os cuento.

Realmente la primer칤sima idea para hacer estos dibujos en R, fue usar un paquete como *igraph*, del que ya hice un post hace tiempo [Igraph](http://enrdados.net/post/graficos-de-red-con-igraph/) u otros como `visNetwork` que aunque no lo he usado parece muy interesante ya que se pueden crear gr치ficos de red interactivos parecidos a los que buscamos.

![red creada con el paquete visNetwork](images/visnetwork.jpg)
El problema que tuve con estos paquetes es que no supe solucionar c칩mo crear los estilos propios para los c칤rculos, as칤 que cambi칠 de estrategia tendr칤a que progrtamar todo desde cero.

Muchos de mis post, m치s que de programaci칩n, son de dise침o gr치fico con R, es una debilidad que tengo, y eso que R no parece un programa bueno para esto, pero al final le sacamos partido, mira sino estos post de hace tiempo:

  * [Ciudad con R](../pintar-un-edificio-con-r)
  * [Dibujar un bosque con R](../hacer-un-bosque-con-r)
  * [츼rboles fractales](../2021-09-23-arboles-con-funciones-recursivas)
  * [Waldeinsamkeit](../waldeinsamkeit)
  * [Dibujar ojos con R](../ojos)

## Descripci칩n del programa

Para empezar me imagin칠 un lienzo sobre el que pintar aleatoriamente unos puntos. La funci칩n `initialize_canvas()` crea este lienzo blanco con el ancho y alto que le pasemos de par치metros.

Despu칠s la funci칩n `generate_circus()` crea una tabla con los puntos que ser치n el centro de los c칤rculos as칤 como algunas caracter칤sticas de estos como el radio y estilo. Los c칤rculos se pintar치n con unos estilos diferentes sacados de las partituras gr치ficas de los *Escalona Brothers*, para crear estos estilos har칠 una funci칩n distinta llamada `draw_circles(circles)`.

Luego de crear los puntos y el correspondiente c칤rculo hay que hacer la jerarqu칤a de red , los enlaces entre c칤rculos. Este apartado me ha llevado m치s pruebas que el resto. se trata de crear los enlaces mediante una estructura jer치rquica familiar, donde algunos c칤rculos act칰an como "padres" de otros. Para esto he creado la funci칩n `assign_family_structure_ii()` que aunque empez칩 siendo muy simple, pues la primera prueba era puramente aleatoria, no quedaba bien y he tenido que meter m치s reglas como dar preferencia a los grandes radios como padres, y la cercan칤a a estos como hijos, as칤 como cierta limitaci칩n de distancia. 

Para unir los padres con los hijos us칠 primero una simple l칤nea, pero no quedaban bien, as칤 que los cambi칠 por *splines*, pero apenas hab칤a diferencia ya que solo usaba los dos puntos de los centros como definici칩n del *spline*. La funcion final llamada `draw_splinessss(circles)` es algo m치s compleja pues a침ade un punto intermedio a la recta entre 2 c칤rculos y lo desplaza para que el spline final tenga cierta curvatura.

Finalmente en la funci칩n `pinta_cuadro_circulos()` junta todo el proceso en una.

## Funciones del Programa

1. **`initialize_canvas(width, height)`**:
   - **Descripci칩n**: Establece el 치rea de dibujo (lienzo) en R, dibuja un rect치ngulo que delimita este lienzo y a침ade una firma con la fecha actual.
   - **Par치metros**:
     - `width`: Ancho del lienzo.
     - `height`: Alto del lienzo.
     
```{r}
## Programa generador de partituras gr치ficas
## Autor: Fernando Villalba
## Fecha: abril 2014
###########################################
  set.seed(123) # semilla aleatoria
# Paso 1: Funci칩n para establecer el lienzo
initialize_canvas <- function(width, height) {
  # incializa el gr치fico en blanco
  plot(NULL, xlim=c(0, width), ylim=c(0, height), type="n", asp=1,axes = FALSE, xlab = "", ylab = "", main = "")
  # pinta un rectangulo de los bordes de ancho 
  rect(0, 0, width, height,lwd=5)
  # Obtener la fecha actual en formato deseado
  fecha_actual <- format(Sys.Date(), "%d %B %Y")
  # A침adir firma y fecha en la esquina inferior derecha
  # Usar bquote para insertar la variable evaluada en la expresi칩n
  firma_fecha <- bquote(italic("VilBer") ~ "-" ~ .(fecha_actual))
 # text(x=95, y=5, labels=firma_fecha, adj=1, cex=0.8, font=3)
  mtext(side=1, line=-1, adj=1, text=firma_fecha, cex=0.8, font=2)
}
```

2. **`generate_circus(num_circles, width, height, min_radius, max_radius, nrad)`**:
   - **Descripci칩n**: Genera un conjunto de c칤rculos con posiciones y radios aleatorios dentro de los l칤mites del lienzo, asegur치ndose de que los c칤rculos no se superpongan m치s de una distancia m칤nima especificada.
   - **Par치metros**:
     - `num_circles`: N칰mero de c칤rculos a generar.
     - `width`, `height`: Dimensiones del lienzo.
     - `min_radius`, `max_radius`: Rango de radios para los c칤rculos.
     - `nrad`: Factor que define la separaci칩n m칤nima entre c칤rculos en funci칩n de su radio.
     
```{r}
# Paso 2: Funci칩n para crear la tabla con los datos de los circulos
generate_circus <- function(num_circles, width, height, min_radius, max_radius, nrad) {
  # num_circles = numero de circulos en el lienzo
  # width, height = ancho y alto del lienzo 
  # min_radius, max_radius = min y max valor del radio de los circulos generados
  # nrad = indica la distancia de separaci칩n minima de los circulos, para que no se superpongan en numero de veces el radio maximo
  circles <- data.frame(id = integer(0), x = numeric(0), y = numeric(0), radius = numeric(0), estilo = integer(0),id_padre = integer(0))
  max_attempts <- 1000  # L칤mite de intentos para evitar bucles infinitos
  
  for (i in 1:num_circles) {
    valid <- FALSE
    attempts <- 0
    
    while (!valid && attempts < max_attempts) {
      # Genera un nuevo punto y radio
      new_x <- runif(1, min_radius, width - min_radius)
      new_y <- runif(1, min_radius, height - min_radius)
      new_radius <- runif(1, min_radius, max_radius)
      attempts <- attempts + 1
      
      # Verifica la distancia con todos los c칤rculos ya creados
      if (nrow(circles) == 0) {
        valid <- TRUE
      } else {
        distances <- sqrt((circles$x - new_x)^2 + (circles$y - new_y)^2)
        min_distance_needed <- nrad * max(max_radius, new_radius)  # nrad veces el radio m치ximo de cualquiera
        valid <- all(distances >= min_distance_needed)
      }
    }
    
    if (valid) {
      style <- sample(1:5, 1)
      circles <- rbind(circles, data.frame(id = i, x = new_x, y = new_y, radius = new_radius, estilo=style, id_padre = 0))
    } else {
      stop("No fue posible colocar todos los c칤rculos tras ", max_attempts, " intentos.")
    }
  }
  
  # Asignaci칩n de ID del padre (opcional y personalizable)
circles$id_padre <- sapply(circles$id, function(x) {
  if (runif(1) < 0.7) {
    # 70% de probabilidad de que el c칤rculo no tenga padre
    return(0)
  } else {
    # Los c칤rculos con radios mayores tienen m치s posibilidad de ser elegidos como padres
    # Calculamos pesos, donde el peso es proporcional al radio
    weights <- circles$radius / min(circles$radius)  # Esto asegura que el c칤rculo m치s peque침o tenga peso 1
    weights <- weights * ifelse(circles$radius >= median(circles$radius), 3, 1)  # Doble de peso si el radio es mayor o igual que la mediana
    
    # Asegurarse de no incluir el propio c칤rculo como su padre
    weights[x] <- 0
    
    # Selecciona un id de padre de acuerdo con los pesos
    return(sample(circles$id, 1, prob = weights))
  }
})

  return(circles)
}
```

3. **`assign_family_structure_ii(circles, width, height)`**:
   - **Descripci칩n**: Asigna una estructura jer치rquica de relaciones padre-hijo a los c칤rculos basada en su proximidad y tama침o. Los c칤rculos solo pueden ser padres de otros c칤rculos si est치n dentro de una distancia menor a cuarto de la diagonal del lienzo.
   - **Par치metros**:
     - `circles`: DataFrame de c칤rculos generados.
     - `width`, `height`: Dimensiones del lienzo.

```{r}
# Paso 3: Funci칩n que crea la relaci칩n entre padre-hijo de los circulos
# asigna la estructura de padre hijo
assign_family_structure_ii <- function(circles, width, height) {
  # Calcular 1/4 de la diagonal del lienzo
  max_distance <- 0.25 * sqrt(width^2 + height^2)

  # Ordenar c칤rculos por radio de mayor a menor y resetear 칤ndices
  circles <- circles[order(-circles$radius), ]
  circles$id <- seq_len(nrow(circles))  # Asignar un ID consecutivo a cada c칤rculo
  circles$id_padre <- 0  # Inicializar todos los id_padre a 0

  # Iterar sobre cada c칤rculo para asignar hijos
  for (i in 1:nrow(circles)) {
    if (circles$id_padre[i] == 0) {  # Solo si el c칤rculo no tiene a칰n un padre asignado
      # Determinar cu치ntos hijos asignar
      num_cercanos <- sample(0:(nrow(circles)/4), 1)

      if (num_cercanos > 0) {
        # Calcular distancias desde el c칤rculo actual a todos los dem치s
        distances <- sqrt((circles$x - circles$x[i])^2 + (circles$y - circles$y[i])^2)
        distances[i] <- Inf  # Evitar que un c칤rculo sea su propio hijo

        # Filtrar por distancia m치xima permitida
        within_distance <- distances < max_distance

        # Ordenar por distancia y seleccionar los 'num_cercanos' m치s cercanos que no tengan padre asignado y est칠n dentro del l칤mite de distancia
        closest_indices <- order(distances)
        child_candidates <- closest_indices[circles$id_padre[closest_indices] == 0 & within_distance[closest_indices]][1:num_cercanos]

        # Asignar el id actual como padre a los c칤rculos m치s cercanos sin padre asignado y dentro del l칤mite de distancia
        circles$id_padre[child_candidates] <- circles$id[i]
      }
    }
  }

  return(circles)
}
```

4. **`draw_splinessss(circles)`**:
   - **Descripci칩n**: Dibuja l칤neas curvas (splines) entre c칤rculos padres e hijos para visualizar las relaciones familiares.
   - **Par치metros**:
     - `circles`: DataFrame de c칤rculos con estructura familiar asignada.

```{r}
# Paso 4: Funciones de dibujo 
# dibuja splines entre los centros de los circulos padre e hijos
draw_splinessss <- function(circles) {
  # Asegura que los splines se dibujan sobre los c칤rculos existentes
  par(new = TRUE)

  for (i in 1:nrow(circles)) {
    if (circles$id_padre[i] != 0) {
      # Encuentra el c칤rculo padre
      padre <- circles[circles$id == circles$id_padre[i], ]
      if (nrow(padre) == 1) {  # Aseg칰rate de que el padre existe
        # Define los puntos inicial y final para el spline
        x1 <- circles$x[i]
        y1 <- circles$y[i]
        x2 <- padre$x
        y2 <- padre$y
        radio_menor <- max(circles$radius[i], padre$radius)

        # Calcula el punto medio
        xm <- (x1 + x2) / 2
        ym <- (y1 + y2) / 2

        # Desplazamiento perpendicular a la l칤nea entre los puntos
        # Calcula un vector perpendicular
        dx <- x2 - x1
        dy <- y2 - y1
        # Normaliza y rota 90 grados
        len <- sqrt(dx^2 + dy^2)
        dx_perp <- -dy / len
        dy_perp <- dx / len
        # Calcula el punto de desviaci칩n
        xm_desplazado <- xm + radio_menor * dx_perp
        ym_desplazado <- ym + radio_menor * dy_perp

        # Puntos para xspline incluyen el punto desviado
        x_points <- c(x1, xm_desplazado, x2)
        y_points <- c(y1, ym_desplazado, y2)
        
        # Dibuja un spline entre el hijo y el padre con curvatura
        xspline(x = x_points, y = y_points, shape = sample(c(-1,1), 1), border = "black", lwd = 1)
      }
    }
  }
}
```

5. **`draw_circles(circles)`**:
   - **Descripci칩n**: Visualiza los c칤rculos en el lienzo, aplicando estilos variados que incluyen c칤rculos rellenos, c칤rculos con bordes, y c칤rculos con decoraciones adicionales como mini planetas.
   - **Par치metros**:
     - `circles`: DataFrame de c칤rculos con estilos y posiciones definidas.
     
```{r}

# Funcion que pinta los circulos seg칰n el estilo 
draw_circles <- function(circles) {
  apply(circles, 1, function(circle) {
    # Asigna un estilo de forma aleatoria para demostraci칩n; ajusta seg칰n la l칩gica deseada
    style <- circle["estilo"]# sample(1:5, 1)

    if (style == 1) {
      # Dibujar c칤rculo negro con relleno negro
      symbols(circle["x"], circle["y"], circles=circle["radius"], inches=FALSE, add=TRUE, fg="black", bg="black")
    } else if (style == 2) {
      # Dibujar c칤rculo con borde negro y relleno blanco
      symbols(circle["x"], circle["y"], circles=circle["radius"], inches=FALSE, add=TRUE, fg="black", bg="white")
    } else if (style == 3) {
      # Dibujar c칤rculos conc칠ntricos
      for (i in 2:5) {
        symbols(circle["x"], circle["y"], circles = circle["radius"] * i, inches = FALSE, add = TRUE)
      }
      symbols(circle["x"], circle["y"], circles = circle["radius"] * 4+0.2*circle["radius"], inches = FALSE, add = TRUE)
      symbols(circle["x"], circle["y"], circles = circle["radius"], inches = FALSE, add = TRUE, fg = "black",bg = "black")
    } else if (style == 4) {
      # Dibujar dos c칤rculos conc칠ntricos y una letra encima
      symbols(circle["x"], circle["y"], circles=circle["radius"] * 2, inches=FALSE, add=TRUE, fg="black", bg="white")
      symbols(circle["x"], circle["y"], circles=circle["radius"], inches=FALSE, add=TRUE, fg="black", bg="black")
      angle <- runif(1, 0, 360)  # Genera un 치ngulo aleatorio entre 0 y 360 grados
      text(circle["x"], circle["y"], "lll", col="white", cex=1.5, srt=angle)
  #    text(circle["x"], circle["y"], "lll", col="white", cex=1.5)  # Puedes cambiar "R" por cualquier otra letra
    } else if (style == 5) {
      # Dibuja un circulo con mini planetas alrededor
      # 1. el circulo central
      symbols(circle["x"], circle["y"], circles=circle["radius"], inches=FALSE, add=TRUE, fg="black", bg="black")
      # 2. los planetas
        n_planet=sample(2:5, 1) # numero de planetas 
        for (i in 1:n_planet){
          rad_mini<- circle["radius"] / 4  # un cuarto del radio del planeta central
          r_orbit<- sample(2:5, 1) # dist orbital del planeta en num de radios del central
          ang_planet <- runif(1, min = 0, max = 2*pi) # angulo del planeta en radianes 
        # Calcular la posici칩n de cada mini c칤rculo
          x_mini <- circle["x"] + r_orbit * circle["radius"] * cos(ang_planet)
          y_mini <- circle["y"] + r_orbit * circle["radius"] * sin(ang_planet)
        # Dibujar los mini c칤rculos y las l칤neas que los unen al c칤rculo principal
        # Todos los mini c칤rculos son negros macizos  
          symbols(x_mini, y_mini, circles=rad_mini, inches=FALSE, add=TRUE, fg="black", bg="black") 
        # Dibuja la linea que lo une al planet central     
          lines(c(circle["x"],x_mini ), c(circle["y"], y_mini), col = "black")     
        }
      }
  })# fin de funcion appply
}
```

6. **`pinta_cuadro_circulos(width, height, radio_min, radio_max, rad_cercania, num_circles)`**:
   - **Descripci칩n**: Funci칩n principal que orquesta la creaci칩n del lienzo, la generaci칩n de c칤rculos, la asignaci칩n de la estructura familiar y la visualizaci칩n final de los c칤rculos y sus conexiones.
   - **Par치metros**:
     - `width`, `height`: Dimensiones del lienzo.
     - `radio_min`, `radio_max`: Rango de radios para los c칤rculos.
     - `rad_cercania`: Factor de cercan칤a para evitar superposici칩n de c칤rculos.
     - `num_circles`: N칰mero de c칤rculos a generar.

```{r}
# Funci칩n que recoge todo lo anterior para pintar un cuadro
pinta_cuadro_circulos<-function(width=1000,height=800,radio_min=5,radio_max=50,rad_cercania=1,num_circles=10){
    #num_circles <- sample(3:20, 1)  # N칰mero aleatorio de c칤rculos entre 5 y 20
    par(mar=c(0.1, 0.1, 0.1, 0.1))
    initialize_canvas(width, height)
    clip(0, width, 0, height) # recorta el dibujo por el corte con los ejes
    circles <- generate_circus(num_circles, width, height, radio_min, radio_max, rad_cercania)
    circles1 <-assign_family_structure_ii(circles, width, height)
    draw_splinessss(circles1)
    draw_circles(circles1)
}
```

# Uso

Con cada llamada a la funci칩n `pinta_cuadro_circulos()`, se genera un nuevo lienzo de partitura gr치fica, espero que os guste.

![partitura gr치fica](images/cde12cbb-78a1-483f-a56f-a1ae54b7bdc3.png)

Otro ejemplo:

```{r warning = FALSE, message = FALSE}

pinta_cuadro_circulos(radio_min=2,radio_max=45,rad_cercania=3,num_circles=20)

```