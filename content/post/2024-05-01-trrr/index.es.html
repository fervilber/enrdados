---
title: trrr
author: F.VilBer
date: '2024-05-01'
slug: []
categories:
  - dise√±o
tags:
  - dibujo
  - divertido
description: 'Creacion de partituras gr√°ficas'
thumbnail: '/post/2024-05-01-trrr/images/circulos1.png'
---



<div id="trrr.." class="section level2">
<h2>trrr..</h2>
<p>Qu√© mejor que retomar el blog con un gran arranque onomatop√©yico ‚Äútrrr..‚Äù es el sonido de un temblor, de un rugido de moto, un arranque brutal‚Ä¶ eso es lo que os propongo en este regreso tras una larga ausencia, empecemos!.</p>
<div class="float">
<img src="images/c27724a0-8455-4619-b606-205ea758710a.png" alt="partitura grafica" />
<div class="figcaption">partitura grafica</div>
</div>
<p>Este juego m√∫sico-visual se me ocurri√≥ en Granada hace unos d√≠as. Resulta que estaba paseando por esa bella ciudad y pasamos al patio del palacio de la Madraza, donde hab√≠a una exposici√≥n de los (<em>Escalona Brothers</em>)[<a href="https://lamadraza.ugr.es/evento/trrrr-escalona-brothers/" class="uri">https://lamadraza.ugr.es/evento/trrrr-escalona-brothers/</a>].</p>
<p>En medio del bullicio nocturno de la ciudad, me encontr√© de repente en un precioso patio de esos con encanto <em>granaino</em>. En la sala de exposiciones contigua encontr√© tirado en el suelo un pobre piano maltrecho, destrozado, con su arpa sangrante y una invasi√≥n de extra√±os temblores s√≥nicos.</p>
<p>Me llam√≥ poderosamente la atenci√≥n unos dibujos muy simples de c√≠rculos y l√≠neas en blanco y negro repartidos por la sala de exposiciones. Me qued√© con uno de los folletos de la exposici√≥n en los que pude leer, ya a la ma√±ana siguiente, que se trataba de representaciones de ‚Äú<em>partituras gr√°ficas, compuestas por s√≠mbolos inspirados en mapas de enjambres s√≠smicos</em>‚Äù.</p>
<div class="float">
<img src="images/escalona.jpg" alt="Partitura grafica" />
<div class="figcaption"><em>Partitura grafica</em></div>
</div>
<p>No negar√© que la elegante descripci√≥n de sus creadores me dej√≥ tocado üòÇ, y fue en ese momento cuando pens√© en hacer mi particular versi√≥n de estas <em>‚Äúpartituras gr√°ficas‚Äù</em>, usando, claro est√°, R.</p>
<div class="float">
<img src="images/25b50787-2f29-41ec-b057-5c1a5178aac6.png" alt="Muestra de partitura gr√°fica creada con R" />
<div class="figcaption"><em><em>Muestra de partitura gr√°fica creada con R</em></em></div>
</div>
<p>Las im√°genes de los hermanos Escalona muestran una composici√≥n gr√°fica abstracta en blanco y negro. En ellas hay una serie de c√≠rculos negros conc√©ntricos de diferentes tama√±os y estilos que parecen estar conectados por finas l√≠neas, creando una estructura que podr√≠a asemejarse a una red o un diagrama de conexiones.</p>
</div>
<div id="de-la-idea-al-programa" class="section level1">
<h1>De la idea al programa</h1>
<p>El programa que voy a mostraros es el √∫ltimo de una serie de pruebas que paso a paso han ido conform√°ndose hasta crear las funciones y flujo final, aunque b√°sicamente mantienen la primera idea original que os cuento.</p>
<p>Realmente la primer√≠sima idea para hacer estos dibujos en R, fue usar un paquete como <em>igraph</em>, del que ya hice un post hace tiempo <a href="http://enrdados.net/post/graficos-de-red-con-igraph/">Igraph</a> u otros como <code>visNetwork</code> que aunque no lo he usado parece muy interesante ya que se pueden crear gr√°ficos de red interactivos parecidos a los que buscamos.</p>
<p><img src="images/visnetwork.jpg" alt="red creada con el paquete visNetwork" />
El problema que tuve con estos paquetes es que no supe solucionar c√≥mo crear los estilos propios para los c√≠rculos, as√≠ que cambi√© de estrategia tendr√≠a que progrtamar todo desde cero.</p>
<p>Muchos de mis post, m√°s que de programaci√≥n, son de dise√±o gr√°fico con R, es una debilidad que tengo, y eso que R no parece un programa bueno para esto, pero al final le sacamos partido, mira sino estos post de hace tiempo:</p>
<ul>
<li><a href="../pintar-un-edificio-con-r">Ciudad con R</a></li>
<li><a href="../hacer-un-bosque-con-r">Dibujar un bosque con R</a></li>
<li><a href="../2021-09-23-arboles-con-funciones-recursivas">√Årboles fractales</a></li>
<li><a href="../waldeinsamkeit">Waldeinsamkeit</a></li>
<li><a href="../ojos">Dibujar ojos con R</a></li>
</ul>
<div id="descripci√≥n-del-programa" class="section level2">
<h2>Descripci√≥n del programa</h2>
<p>Para empezar me imagin√© un lienzo sobre el que pintar aleatoriamente unos puntos. La funci√≥n <code>initialize_canvas()</code> crea este lienzo blanco con el ancho y alto que le pasemos de par√°metros.</p>
<p>Despu√©s la funci√≥n <code>generate_circus()</code> crea una tabla con los puntos que ser√°n el centro de los c√≠rculos as√≠ como algunas caracter√≠sticas de estos como el radio y estilo. Los c√≠rculos se pintar√°n con unos estilos diferentes sacados de las partituras gr√°ficas de los <em>Escalona Brothers</em>, para crear estos estilos har√© una funci√≥n distinta llamada <code>draw_circles(circles)</code>.</p>
<p>Luego de crear los puntos y el correspondiente c√≠rculo hay que hacer la jerarqu√≠a de red , los enlaces entre c√≠rculos. Este apartado me ha llevado m√°s pruebas que el resto. se trata de crear los enlaces mediante una estructura jer√°rquica familiar, donde algunos c√≠rculos act√∫an como ‚Äúpadres‚Äù de otros. Para esto he creado la funci√≥n <code>assign_family_structure_ii()</code> que aunque empez√≥ siendo muy simple, pues la primera prueba era puramente aleatoria, no quedaba bien y he tenido que meter m√°s reglas como dar preferencia a los grandes radios como padres, y la cercan√≠a a estos como hijos, as√≠ como cierta limitaci√≥n de distancia.</p>
<p>Para unir los padres con los hijos us√© primero una simple l√≠nea, pero no quedaban bien, as√≠ que los cambi√© por <em>splines</em>, pero apenas hab√≠a diferencia ya que solo usaba los dos puntos de los centros como definici√≥n del <em>spline</em>. La funcion final llamada <code>draw_splinessss(circles)</code> es algo m√°s compleja pues a√±ade un punto intermedio a la recta entre 2 c√≠rculos y lo desplaza para que el spline final tenga cierta curvatura.</p>
<p>Finalmente en la funci√≥n <code>pinta_cuadro_circulos()</code> junta todo el proceso en una.</p>
</div>
<div id="funciones-del-programa" class="section level2">
<h2>Funciones del Programa</h2>
<ol style="list-style-type: decimal">
<li><strong><code>initialize_canvas(width, height)</code></strong>:
<ul>
<li><strong>Descripci√≥n</strong>: Establece el √°rea de dibujo (lienzo) en R, dibuja un rect√°ngulo que delimita este lienzo y a√±ade una firma con la fecha actual.</li>
<li><strong>Par√°metros</strong>:
<ul>
<li><code>width</code>: Ancho del lienzo.</li>
<li><code>height</code>: Alto del lienzo.</li>
</ul></li>
</ul></li>
</ol>
<pre class="r"><code>## Programa generador de partituras gr√°ficas
## Autor: Fernando Villalba
## Fecha: abril 2014
###########################################
  set.seed(123) # semilla aleatoria
# Paso 1: Funci√≥n para establecer el lienzo
initialize_canvas &lt;- function(width, height) {
  # incializa el gr√°fico en blanco
  plot(NULL, xlim=c(0, width), ylim=c(0, height), type=&quot;n&quot;, asp=1,axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot;)
  # pinta un rectangulo de los bordes de ancho 
  rect(0, 0, width, height,lwd=5)
  # Obtener la fecha actual en formato deseado
  fecha_actual &lt;- format(Sys.Date(), &quot;%d %B %Y&quot;)
  # A√±adir firma y fecha en la esquina inferior derecha
  # Usar bquote para insertar la variable evaluada en la expresi√≥n
  firma_fecha &lt;- bquote(italic(&quot;VilBer&quot;) ~ &quot;-&quot; ~ .(fecha_actual))
 # text(x=95, y=5, labels=firma_fecha, adj=1, cex=0.8, font=3)
  mtext(side=1, line=-1, adj=1, text=firma_fecha, cex=0.8, font=2)
}</code></pre>
<ol start="2" style="list-style-type: decimal">
<li><strong><code>generate_circus(num_circles, width, height, min_radius, max_radius, nrad)</code></strong>:
<ul>
<li><strong>Descripci√≥n</strong>: Genera un conjunto de c√≠rculos con posiciones y radios aleatorios dentro de los l√≠mites del lienzo, asegur√°ndose de que los c√≠rculos no se superpongan m√°s de una distancia m√≠nima especificada.</li>
<li><strong>Par√°metros</strong>:
<ul>
<li><code>num_circles</code>: N√∫mero de c√≠rculos a generar.</li>
<li><code>width</code>, <code>height</code>: Dimensiones del lienzo.</li>
<li><code>min_radius</code>, <code>max_radius</code>: Rango de radios para los c√≠rculos.</li>
<li><code>nrad</code>: Factor que define la separaci√≥n m√≠nima entre c√≠rculos en funci√≥n de su radio.</li>
</ul></li>
</ul></li>
</ol>
<pre class="r"><code># Paso 2: Funci√≥n para crear la tabla con los datos de los circulos
generate_circus &lt;- function(num_circles, width, height, min_radius, max_radius, nrad) {
  # num_circles = numero de circulos en el lienzo
  # width, height = ancho y alto del lienzo 
  # min_radius, max_radius = min y max valor del radio de los circulos generados
  # nrad = indica la distancia de separaci√≥n minima de los circulos, para que no se superpongan en numero de veces el radio maximo
  circles &lt;- data.frame(id = integer(0), x = numeric(0), y = numeric(0), radius = numeric(0), estilo = integer(0),id_padre = integer(0))
  max_attempts &lt;- 1000  # L√≠mite de intentos para evitar bucles infinitos
  
  for (i in 1:num_circles) {
    valid &lt;- FALSE
    attempts &lt;- 0
    
    while (!valid &amp;&amp; attempts &lt; max_attempts) {
      # Genera un nuevo punto y radio
      new_x &lt;- runif(1, min_radius, width - min_radius)
      new_y &lt;- runif(1, min_radius, height - min_radius)
      new_radius &lt;- runif(1, min_radius, max_radius)
      attempts &lt;- attempts + 1
      
      # Verifica la distancia con todos los c√≠rculos ya creados
      if (nrow(circles) == 0) {
        valid &lt;- TRUE
      } else {
        distances &lt;- sqrt((circles$x - new_x)^2 + (circles$y - new_y)^2)
        min_distance_needed &lt;- nrad * max(max_radius, new_radius)  # nrad veces el radio m√°ximo de cualquiera
        valid &lt;- all(distances &gt;= min_distance_needed)
      }
    }
    
    if (valid) {
      style &lt;- sample(1:5, 1)
      circles &lt;- rbind(circles, data.frame(id = i, x = new_x, y = new_y, radius = new_radius, estilo=style, id_padre = 0))
    } else {
      stop(&quot;No fue posible colocar todos los c√≠rculos tras &quot;, max_attempts, &quot; intentos.&quot;)
    }
  }
  
  # Asignaci√≥n de ID del padre (opcional y personalizable)
circles$id_padre &lt;- sapply(circles$id, function(x) {
  if (runif(1) &lt; 0.7) {
    # 70% de probabilidad de que el c√≠rculo no tenga padre
    return(0)
  } else {
    # Los c√≠rculos con radios mayores tienen m√°s posibilidad de ser elegidos como padres
    # Calculamos pesos, donde el peso es proporcional al radio
    weights &lt;- circles$radius / min(circles$radius)  # Esto asegura que el c√≠rculo m√°s peque√±o tenga peso 1
    weights &lt;- weights * ifelse(circles$radius &gt;= median(circles$radius), 3, 1)  # Doble de peso si el radio es mayor o igual que la mediana
    
    # Asegurarse de no incluir el propio c√≠rculo como su padre
    weights[x] &lt;- 0
    
    # Selecciona un id de padre de acuerdo con los pesos
    return(sample(circles$id, 1, prob = weights))
  }
})

  return(circles)
}</code></pre>
<ol start="3" style="list-style-type: decimal">
<li><strong><code>assign_family_structure_ii(circles, width, height)</code></strong>:
<ul>
<li><strong>Descripci√≥n</strong>: Asigna una estructura jer√°rquica de relaciones padre-hijo a los c√≠rculos basada en su proximidad y tama√±o. Los c√≠rculos solo pueden ser padres de otros c√≠rculos si est√°n dentro de una distancia menor a cuarto de la diagonal del lienzo.</li>
<li><strong>Par√°metros</strong>:
<ul>
<li><code>circles</code>: DataFrame de c√≠rculos generados.</li>
<li><code>width</code>, <code>height</code>: Dimensiones del lienzo.</li>
</ul></li>
</ul></li>
</ol>
<pre class="r"><code># Paso 3: Funci√≥n que crea la relaci√≥n entre padre-hijo de los circulos
# asigna la estructura de padre hijo
assign_family_structure_ii &lt;- function(circles, width, height) {
  # Calcular 1/4 de la diagonal del lienzo
  max_distance &lt;- 0.25 * sqrt(width^2 + height^2)

  # Ordenar c√≠rculos por radio de mayor a menor y resetear √≠ndices
  circles &lt;- circles[order(-circles$radius), ]
  circles$id &lt;- seq_len(nrow(circles))  # Asignar un ID consecutivo a cada c√≠rculo
  circles$id_padre &lt;- 0  # Inicializar todos los id_padre a 0

  # Iterar sobre cada c√≠rculo para asignar hijos
  for (i in 1:nrow(circles)) {
    if (circles$id_padre[i] == 0) {  # Solo si el c√≠rculo no tiene a√∫n un padre asignado
      # Determinar cu√°ntos hijos asignar
      num_cercanos &lt;- sample(0:(nrow(circles)/4), 1)

      if (num_cercanos &gt; 0) {
        # Calcular distancias desde el c√≠rculo actual a todos los dem√°s
        distances &lt;- sqrt((circles$x - circles$x[i])^2 + (circles$y - circles$y[i])^2)
        distances[i] &lt;- Inf  # Evitar que un c√≠rculo sea su propio hijo

        # Filtrar por distancia m√°xima permitida
        within_distance &lt;- distances &lt; max_distance

        # Ordenar por distancia y seleccionar los &#39;num_cercanos&#39; m√°s cercanos que no tengan padre asignado y est√©n dentro del l√≠mite de distancia
        closest_indices &lt;- order(distances)
        child_candidates &lt;- closest_indices[circles$id_padre[closest_indices] == 0 &amp; within_distance[closest_indices]][1:num_cercanos]

        # Asignar el id actual como padre a los c√≠rculos m√°s cercanos sin padre asignado y dentro del l√≠mite de distancia
        circles$id_padre[child_candidates] &lt;- circles$id[i]
      }
    }
  }

  return(circles)
}</code></pre>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>draw_splinessss(circles)</code></strong>:
<ul>
<li><strong>Descripci√≥n</strong>: Dibuja l√≠neas curvas (splines) entre c√≠rculos padres e hijos para visualizar las relaciones familiares.</li>
<li><strong>Par√°metros</strong>:
<ul>
<li><code>circles</code>: DataFrame de c√≠rculos con estructura familiar asignada.</li>
</ul></li>
</ul></li>
</ol>
<pre class="r"><code># Paso 4: Funciones de dibujo 
# dibuja splines entre los centros de los circulos padre e hijos
draw_splinessss &lt;- function(circles) {
  # Asegura que los splines se dibujan sobre los c√≠rculos existentes
  par(new = TRUE)

  for (i in 1:nrow(circles)) {
    if (circles$id_padre[i] != 0) {
      # Encuentra el c√≠rculo padre
      padre &lt;- circles[circles$id == circles$id_padre[i], ]
      if (nrow(padre) == 1) {  # Aseg√∫rate de que el padre existe
        # Define los puntos inicial y final para el spline
        x1 &lt;- circles$x[i]
        y1 &lt;- circles$y[i]
        x2 &lt;- padre$x
        y2 &lt;- padre$y
        radio_menor &lt;- max(circles$radius[i], padre$radius)

        # Calcula el punto medio
        xm &lt;- (x1 + x2) / 2
        ym &lt;- (y1 + y2) / 2

        # Desplazamiento perpendicular a la l√≠nea entre los puntos
        # Calcula un vector perpendicular
        dx &lt;- x2 - x1
        dy &lt;- y2 - y1
        # Normaliza y rota 90 grados
        len &lt;- sqrt(dx^2 + dy^2)
        dx_perp &lt;- -dy / len
        dy_perp &lt;- dx / len
        # Calcula el punto de desviaci√≥n
        xm_desplazado &lt;- xm + radio_menor * dx_perp
        ym_desplazado &lt;- ym + radio_menor * dy_perp

        # Puntos para xspline incluyen el punto desviado
        x_points &lt;- c(x1, xm_desplazado, x2)
        y_points &lt;- c(y1, ym_desplazado, y2)
        
        # Dibuja un spline entre el hijo y el padre con curvatura
        xspline(x = x_points, y = y_points, shape = sample(c(-1,1), 1), border = &quot;black&quot;, lwd = 1)
      }
    }
  }
}</code></pre>
<ol start="5" style="list-style-type: decimal">
<li><strong><code>draw_circles(circles)</code></strong>:
<ul>
<li><strong>Descripci√≥n</strong>: Visualiza los c√≠rculos en el lienzo, aplicando estilos variados que incluyen c√≠rculos rellenos, c√≠rculos con bordes, y c√≠rculos con decoraciones adicionales como mini planetas.</li>
<li><strong>Par√°metros</strong>:
<ul>
<li><code>circles</code>: DataFrame de c√≠rculos con estilos y posiciones definidas.</li>
</ul></li>
</ul></li>
</ol>
<pre class="r"><code># Funcion que pinta los circulos seg√∫n el estilo 
draw_circles &lt;- function(circles) {
  apply(circles, 1, function(circle) {
    # Asigna un estilo de forma aleatoria para demostraci√≥n; ajusta seg√∫n la l√≥gica deseada
    style &lt;- circle[&quot;estilo&quot;]# sample(1:5, 1)

    if (style == 1) {
      # Dibujar c√≠rculo negro con relleno negro
      symbols(circle[&quot;x&quot;], circle[&quot;y&quot;], circles=circle[&quot;radius&quot;], inches=FALSE, add=TRUE, fg=&quot;black&quot;, bg=&quot;black&quot;)
    } else if (style == 2) {
      # Dibujar c√≠rculo con borde negro y relleno blanco
      symbols(circle[&quot;x&quot;], circle[&quot;y&quot;], circles=circle[&quot;radius&quot;], inches=FALSE, add=TRUE, fg=&quot;black&quot;, bg=&quot;white&quot;)
    } else if (style == 3) {
      # Dibujar c√≠rculos conc√©ntricos
      for (i in 2:5) {
        symbols(circle[&quot;x&quot;], circle[&quot;y&quot;], circles = circle[&quot;radius&quot;] * i, inches = FALSE, add = TRUE)
      }
      symbols(circle[&quot;x&quot;], circle[&quot;y&quot;], circles = circle[&quot;radius&quot;] * 4+0.2*circle[&quot;radius&quot;], inches = FALSE, add = TRUE)
      symbols(circle[&quot;x&quot;], circle[&quot;y&quot;], circles = circle[&quot;radius&quot;], inches = FALSE, add = TRUE, fg = &quot;black&quot;,bg = &quot;black&quot;)
    } else if (style == 4) {
      # Dibujar dos c√≠rculos conc√©ntricos y una letra encima
      symbols(circle[&quot;x&quot;], circle[&quot;y&quot;], circles=circle[&quot;radius&quot;] * 2, inches=FALSE, add=TRUE, fg=&quot;black&quot;, bg=&quot;white&quot;)
      symbols(circle[&quot;x&quot;], circle[&quot;y&quot;], circles=circle[&quot;radius&quot;], inches=FALSE, add=TRUE, fg=&quot;black&quot;, bg=&quot;black&quot;)
      angle &lt;- runif(1, 0, 360)  # Genera un √°ngulo aleatorio entre 0 y 360 grados
      text(circle[&quot;x&quot;], circle[&quot;y&quot;], &quot;lll&quot;, col=&quot;white&quot;, cex=1.5, srt=angle)
  #    text(circle[&quot;x&quot;], circle[&quot;y&quot;], &quot;lll&quot;, col=&quot;white&quot;, cex=1.5)  # Puedes cambiar &quot;R&quot; por cualquier otra letra
    } else if (style == 5) {
      # Dibuja un circulo con mini planetas alrededor
      # 1. el circulo central
      symbols(circle[&quot;x&quot;], circle[&quot;y&quot;], circles=circle[&quot;radius&quot;], inches=FALSE, add=TRUE, fg=&quot;black&quot;, bg=&quot;black&quot;)
      # 2. los planetas
        n_planet=sample(2:5, 1) # numero de planetas 
        for (i in 1:n_planet){
          rad_mini&lt;- circle[&quot;radius&quot;] / 4  # un cuarto del radio del planeta central
          r_orbit&lt;- sample(2:5, 1) # dist orbital del planeta en num de radios del central
          ang_planet &lt;- runif(1, min = 0, max = 2*pi) # angulo del planeta en radianes 
        # Calcular la posici√≥n de cada mini c√≠rculo
          x_mini &lt;- circle[&quot;x&quot;] + r_orbit * circle[&quot;radius&quot;] * cos(ang_planet)
          y_mini &lt;- circle[&quot;y&quot;] + r_orbit * circle[&quot;radius&quot;] * sin(ang_planet)
        # Dibujar los mini c√≠rculos y las l√≠neas que los unen al c√≠rculo principal
        # Todos los mini c√≠rculos son negros macizos  
          symbols(x_mini, y_mini, circles=rad_mini, inches=FALSE, add=TRUE, fg=&quot;black&quot;, bg=&quot;black&quot;) 
        # Dibuja la linea que lo une al planet central     
          lines(c(circle[&quot;x&quot;],x_mini ), c(circle[&quot;y&quot;], y_mini), col = &quot;black&quot;)     
        }
      }
  })# fin de funcion appply
}</code></pre>
<ol start="6" style="list-style-type: decimal">
<li><strong><code>pinta_cuadro_circulos(width, height, radio_min, radio_max, rad_cercania, num_circles)</code></strong>:
<ul>
<li><strong>Descripci√≥n</strong>: Funci√≥n principal que orquesta la creaci√≥n del lienzo, la generaci√≥n de c√≠rculos, la asignaci√≥n de la estructura familiar y la visualizaci√≥n final de los c√≠rculos y sus conexiones.</li>
<li><strong>Par√°metros</strong>:
<ul>
<li><code>width</code>, <code>height</code>: Dimensiones del lienzo.</li>
<li><code>radio_min</code>, <code>radio_max</code>: Rango de radios para los c√≠rculos.</li>
<li><code>rad_cercania</code>: Factor de cercan√≠a para evitar superposici√≥n de c√≠rculos.</li>
<li><code>num_circles</code>: N√∫mero de c√≠rculos a generar.</li>
</ul></li>
</ul></li>
</ol>
<pre class="r"><code># Funci√≥n que recoge todo lo anterior para pintar un cuadro
pinta_cuadro_circulos&lt;-function(width=1000,height=800,radio_min=5,radio_max=50,rad_cercania=1,num_circles=10){
    #num_circles &lt;- sample(3:20, 1)  # N√∫mero aleatorio de c√≠rculos entre 5 y 20
    par(mar=c(0.1, 0.1, 0.1, 0.1))
    initialize_canvas(width, height)
    clip(0, width, 0, height) # recorta el dibujo por el corte con los ejes
    circles &lt;- generate_circus(num_circles, width, height, radio_min, radio_max, rad_cercania)
    circles1 &lt;-assign_family_structure_ii(circles, width, height)
    draw_splinessss(circles1)
    draw_circles(circles1)
}</code></pre>
</div>
</div>
<div id="uso" class="section level1">
<h1>Uso</h1>
<p>Con cada llamada a la funci√≥n <code>pinta_cuadro_circulos()</code>, se genera un nuevo lienzo de partitura gr√°fica, espero que os guste.</p>
<div class="float">
<img src="images/cde12cbb-78a1-483f-a56f-a1ae54b7bdc3.png" alt="partitura gr√°fica" />
<div class="figcaption">partitura gr√°fica</div>
</div>
<p>Otro ejemplo:</p>
<pre class="r"><code>pinta_cuadro_circulos(radio_min=2,radio_max=45,rad_cercania=3,num_circles=20)</code></pre>
<p><img src="{{< blogdown/postref >}}index.es_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<pre><code>## NULL</code></pre>
</div>
